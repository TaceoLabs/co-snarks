use std::{fs::File, io::BufReader, path::PathBuf};

use ark_bn254::Bn254;
use circom_types::{groth16::zkey::ZKey, r1cs::R1CS};
use clap::{Parser, Subcommand};
use collaborative_circom::{config::NetworkConfig, file_utils};
use color_eyre::eyre::Context;

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Splits an existing witness file generated by Circom into secret shares for use in MPC
    SplitWitness {
        /// The path to the input witness file generated by Circom
        #[arg(long)]
        input: PathBuf,
        /// The MPC protocol to be used
        #[arg(long)]
        protocol: String, // TODO: which datatype? an enum?
        /// The path to the (existing) output directory
        #[arg(long)]
        out_dir: PathBuf,
    },
    /// Splits a JSON input file into secret shares for use in MPC
    SplitInput {
        /// The path to the input JSON file
        #[arg(long)]
        input: PathBuf,
        /// The MPC protocol to be used
        #[arg(long)]
        protocol: String, // TODO: which datatype? an enum?
        /// The path to the (existing) output directory
        #[arg(long)]
        out_dir: PathBuf,
    },
    /// Evaluates the extended witness generation for the specified circuit and input share in MPC
    GenerateWitness {
        /// The path to the input share file
        #[arg(long)]
        input: PathBuf,
        /// The path to the circuit file
        #[arg(long)]
        circuit: PathBuf,
        /// The MPC protocol to be used
        #[arg(long)]
        protocol: String, // TODO: which datatype? an enum?
        /// The path to MPC network configuration file
        #[arg(long)]
        config: PathBuf,
        /// The output file where the final witness share is written to
        #[arg(long)]
        out: PathBuf,
    },
    /// Evaluates the prover algorithm for the specified circuit and witness share in MPC
    GenerateProof {
        /// The path to the witness share file
        #[arg(long)]
        witness: PathBuf,
        /// The path to the r1cs file, generated by Circom compiler
        #[arg(long)]
        r1cs: PathBuf,
        /// The path to the proving key (.zkey) file, generated by snarkjs setup phase
        #[arg(long)]
        zkey: PathBuf,
        /// The MPC protocol to be used
        #[arg(long)]
        protocol: String, // TODO: which datatype? an enum?
        /// The path to MPC network configuration file
        #[arg(long)]
        config: PathBuf,
        /// The output file where the final proof is written to
        #[arg(long)]
        out: PathBuf,
    },
}

fn main() -> color_eyre::Result<()> {
    let args = Cli::parse();

    match args.command {
        Commands::SplitWitness {
            input,
            protocol: _,
            out_dir,
        } => {
            file_utils::check_file_exists(&input)?;
            file_utils::check_dir_exists(&out_dir)?;

            // read the Circom witness file

            // construct relevant protocol

            // create witness shares

            // write out the shares to the output directory
        }
        Commands::SplitInput {
            input,
            protocol: _,
            out_dir,
        } => {
            file_utils::check_file_exists(&input)?;
            file_utils::check_dir_exists(&out_dir)?;

            // read the input file

            // construct relevant protocol

            // create input shares

            // write out the shares to the output directory
        }
        Commands::GenerateWitness {
            input,
            circuit,
            protocol: _,
            config,
            out,
        } => {
            file_utils::check_file_exists(&input)?;
            file_utils::check_file_exists(&circuit)?;
            file_utils::check_file_exists(&config)?;

            // parse input shares

            // parse circuit file & put through our compiler

            // parse network configuration
            let config = std::fs::read_to_string(config)?;
            let _config: NetworkConfig = toml::from_str(&config)?;

            // construct relevant protocol

            // connect to network

            // execute witness generation in MPC

            // write result to output file
            let _out_file = std::fs::File::create(out)?;
        }
        Commands::GenerateProof {
            witness,
            r1cs,
            zkey,
            protocol: _,
            config,
            out,
        } => {
            file_utils::check_file_exists(&witness)?;
            file_utils::check_file_exists(&r1cs)?;
            file_utils::check_file_exists(&zkey)?;
            file_utils::check_file_exists(&config)?;

            // parse witness shares
            let witness_file =
                BufReader::new(File::open(witness).context("trying to open witness share file")?);

            // TODO: how to best allow for different MPC protocols here
            let witness_share = todo!();

            // parse Circom r1cs file
            let r1cs_file = BufReader::new(File::open(r1cs).context("trying to open R1CS file")?);
            // TODO: allow different curves: move all of this into a generic function and match on curve...
            let r1cs =
                R1CS::<Bn254>::from_reader(r1cs_file).context("trying to parse R1CS file")?;

            // parse Circom zkey file
            let zkey_file = File::open(zkey)?;
            let (pk, _) = ZKey::<Bn254>::from_reader(zkey_file).unwrap().split();

            // parse network configuration
            let config = std::fs::read_to_string(config)?;
            let _config: NetworkConfig = toml::from_str(&config)?;

            // construct relevant protocol

            // connect to network

            // execute prover in MPC

            // write result to output file
            let _out_file = std::fs::File::create(out)?;
        }
    }

    Ok(())
}

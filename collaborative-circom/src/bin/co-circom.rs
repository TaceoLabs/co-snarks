use ark_bls12_381::Bls12_381;
use ark_bn254::Bn254;
use ark_ec::pairing::Pairing;
use ark_ff::PrimeField;
use ark_groth16::{Groth16, Proof as Groth16Proof};
use circom_mpc_compiler::CompilerBuilder;
use circom_types::r1cs::R1CS;
use circom_types::{
    groth16::{
        proof::JsonProof as Groth16JsonProof,
        verification_key::JsonVerificationKey as Groth16JsonVerificationKey, witness::Witness,
        zkey::ZKey as Groth16ZKey,
    },
    plonk::{JsonVerificationKey as PlonkJsonVerificationKey, PlonkProof, ZKey as PlonkZKey},
    traits::{CircomArkworksPairingBridge, CircomArkworksPrimeFieldBridge},
};
use clap::{Parser, Subcommand};
use collaborative_circom::{file_utils, Config, MPCCurve, MPCProtocol, ProofSystem};
use collaborative_groth16::groth16::{CollaborativeGroth16, SharedInput, SharedWitness};
use collaborative_plonk::{plonk::Plonk, CollaborativePlonk};
use color_eyre::eyre::{eyre, Context, ContextCompat};
use mpc_core::{
    protocols::{
        rep3::{self, network::Rep3MpcNet, Rep3Protocol},
        shamir::{network::ShamirMpcNet, ShamirProtocol},
    },
    traits::{FFTPostProcessing, PrimeFieldMpcProtocol},
};
use num_bigint::BigUint;
use num_traits::{identities::Zero, Num};
use std::{
    fs::File,
    io::{BufReader, BufWriter},
    path::PathBuf,
    process::ExitCode,
};

fn install_tracing() {
    use tracing_subscriber::prelude::*;
    use tracing_subscriber::{fmt, EnvFilter};

    let fmt_layer = fmt::layer().with_target(true).with_line_number(true);
    let filter_layer = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .init();
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Splits an existing witness file generated by Circom into secret shares for use in MPC
    SplitWitness {
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the input witness file generated by Circom
        #[arg(long)]
        witness: PathBuf,
        /// The path to the r1cs file, generated by Circom compiler
        #[arg(long)]
        r1cs: PathBuf,
        /// The MPC protocol to be used
        #[arg(long, value_enum)]
        protocol: Option<MPCProtocol>,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The path to the (existing) output directory
        #[arg(long)]
        out_dir: PathBuf,
        /// The threshold of tolerated colluding parties
        #[arg(short, long, default_value_t = 1)]
        threshold: usize,
        /// The number of parties
        #[arg(short, long, default_value_t = 3)]
        num_parties: usize,
    },
    /// Splits a JSON input file into secret shares for use in MPC
    SplitInput {
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the input JSON file
        #[arg(long)]
        input: PathBuf,
        /// The path to the circuit file
        #[arg(long)]
        circuit: String,
        /// The path to Circom library files
        #[arg(long)]
        link_library: Vec<String>,
        /// The MPC protocol to be used
        #[arg(long, value_enum)]
        protocol: Option<MPCProtocol>,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The path to the (existing) output directory
        #[arg(long)]
        out_dir: PathBuf,
    },
    /// Merge multiple shared inputs received from multiple parties into a single one
    MergeInputShares {
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the input JSON file
        #[arg(long)]
        inputs: Vec<PathBuf>,
        /// The MPC protocol to be used
        #[arg(long, value_enum)]
        protocol: Option<MPCProtocol>,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The output file where the merged input share is written to
        #[arg(long)]
        out: PathBuf,
    },
    /// Evaluates the extended witness generation for the specified circuit and input share in MPC
    GenerateWitness {
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the input share file
        #[arg(long)]
        input: PathBuf,
        /// The path to the circuit file
        #[arg(long)]
        circuit: String,
        /// The path to Circom library files
        #[arg(long)]
        link_library: Vec<String>,
        /// The MPC protocol to be used
        #[arg(long, value_enum)]
        protocol: Option<MPCProtocol>,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The output file where the final witness share is written to
        #[arg(long)]
        out: PathBuf,
    },
    /// Translates the witness generated with one MPC protocol to a witness for a different one
    TranslateWitness {
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the witness share file
        #[arg(long)]
        witness: PathBuf,
        /// The MPC protocol that was used for the witness generation
        #[arg(long, value_enum)]
        src_protocol: MPCProtocol,
        /// The MPC protocol to be used for the proof generation
        #[arg(long, value_enum)]
        target_protocol: MPCProtocol,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The output file where the final witness share is written to
        #[arg(long)]
        out: PathBuf,
    },
    /// Evaluates the prover algorithm for the specified circuit and witness share in MPC
    GenerateProof {
        // The proof system to be used
        proofsystem: ProofSystem,
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the witness share file
        #[arg(long)]
        witness: PathBuf,
        /// The path to the proving key (.zkey) file, generated by snarkjs setup phase
        #[arg(long)]
        zkey: PathBuf,
        /// The MPC protocol to be used
        #[arg(long, value_enum)]
        protocol: Option<MPCProtocol>,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The output file where the final proof is written to. If not passed, this party will not write the proof to a file.
        #[arg(long)]
        out: Option<PathBuf>,
        /// The output JSON file where the public inputs are written to. If not passed, this party will not write the public inputs to a file.
        #[arg(long)]
        public_input: Option<PathBuf>,
        /// The threshold of tolerated colluding parties
        #[arg(short, long, default_value_t = 1)]
        threshold: usize,
    },
    /// Verification of a Circom proof.
    Verify {
        // The proof system to be used
        proofsystem: ProofSystem,
        /// The path to the config file
        #[arg(long)]
        config: PathBuf,
        /// The path to the proof file
        #[arg(long)]
        proof: PathBuf,
        /// The pairing friendly curve to be used
        #[arg(long, value_enum)]
        curve: Option<MPCCurve>,
        /// The path to the verification key file
        #[arg(long)]
        vk: PathBuf,
        /// The path to the public input JSON file
        #[arg(long)]
        public_input: PathBuf,
    },
}

impl Commands {
    fn get_config_path(&self) -> &PathBuf {
        match self {
            Self::SplitWitness { config, .. } => config,
            Self::SplitInput { config, .. } => config,
            Self::MergeInputShares { config, .. } => config,
            Self::GenerateWitness { config, .. } => config,
            Self::TranslateWitness { config, .. } => config,
            Self::GenerateProof { config, .. } => config,
            Self::Verify { config, .. } => config,
        }
    }

    fn get_curve(&self) -> Option<MPCCurve> {
        match self {
            Self::SplitWitness { curve, .. } => *curve,
            Self::SplitInput { curve, .. } => *curve,
            Self::MergeInputShares { curve, .. } => *curve,
            Self::GenerateWitness { curve, .. } => *curve,
            Self::TranslateWitness { curve, .. } => *curve,
            Self::GenerateProof { curve, .. } => *curve,
            Self::Verify { curve, .. } => *curve,
        }
    }
}

fn main() -> color_eyre::Result<ExitCode> {
    install_tracing();
    let args = Cli::parse();
    let config_path = args.command.get_config_path();

    file_utils::check_file_exists(config_path)?;

    // parse and merge config from env and config file
    let config = Config::new(config_path.to_str().context("invalid path")?)
        .context("expected valid config")?;

    // verify that curve is set in args or config
    let curve = args
        .command
        .get_curve()
        .or(config.curve)
        .context("expected curve either in args or config")?;

    match curve {
        MPCCurve::BN254 => main_function::<Bn254>(args, config),
        MPCCurve::BLS12_381 => main_function::<Bls12_381>(args, config),
    }
}

fn main_function<P: Pairing + CircomArkworksPairingBridge>(
    args: Cli,
    cfg: Config,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: FFTPostProcessing + CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
    Groth16JsonProof<P>: From<Groth16Proof<P>>,
    Groth16Proof<P>: From<Groth16JsonProof<P>>,
{
    match args.command {
        Commands::SplitWitness {
            config: _,
            witness: witness_path,
            r1cs,
            protocol,
            curve: _,
            out_dir,
            threshold: t,
            num_parties: n,
        } => {
            file_utils::check_file_exists(&witness_path)?;
            file_utils::check_file_exists(&r1cs)?;
            file_utils::check_dir_exists(&out_dir)?;

            // verify that protocol is set in args or config
            let protocol = protocol
                .or(cfg.protocol)
                .context("protocol required for this command")?;

            // read the Circom witness file
            let witness_file =
                BufReader::new(File::open(&witness_path).context("while opening witness file")?);
            let witness = Witness::<P::ScalarField>::from_reader(witness_file)
                .context("while parsing witness file")?;

            // read the Circom r1cs file
            let r1cs_file = BufReader::new(File::open(&r1cs).context("while opening r1cs file")?);
            let r1cs = R1CS::<P>::from_reader(r1cs_file).context("while parsing r1cs file")?;

            let mut rng = rand::thread_rng();

            match protocol {
                MPCProtocol::REP3 => {
                    if t != 1 {
                        return Err(eyre!("REP3 only allows the threshold to be 1"));
                    }
                    if n != 3 {
                        return Err(eyre!("REP3 only allows the number of parties to be 3"));
                    }
                    // create witness shares
                    let shares =
                        SharedWitness::<Rep3Protocol<P::ScalarField, Rep3MpcNet>, P>::share_rep3(
                            witness,
                            r1cs.num_inputs,
                            &mut rng,
                        );

                    // write out the shares to the output directory
                    let base_name = witness_path
                        .file_name()
                        .context("we have a file name")?
                        .to_str()
                        .context("witness file name is not valid UTF-8")?;
                    for (i, share) in shares.iter().enumerate() {
                        let path = out_dir.join(format!("{}.{}.shared", base_name, i));
                        let out_file = BufWriter::new(
                            File::create(&path).context("while creating output file")?,
                        );
                        bincode::serialize_into(out_file, share)
                            .context("while serializing witness share")?;
                        tracing::info!("Wrote witness share {} to file {}", i, path.display());
                    }
                }
                MPCProtocol::SHAMIR => {
                    // create witness shares
                    let shares =
                        SharedWitness::<ShamirProtocol<P::ScalarField, ShamirMpcNet>, P>::share_shamir(
                            witness,
                            r1cs.num_inputs,t,n,
                            &mut rng,
                        );

                    // write out the shares to the output directory
                    let base_name = witness_path
                        .file_name()
                        .context("we have a file name")?
                        .to_str()
                        .context("witness file name is not valid UTF-8")?;
                    for (i, share) in shares.iter().enumerate() {
                        let path = out_dir.join(format!("{}.{}.shared", base_name, i));
                        let out_file = BufWriter::new(
                            File::create(&path).context("while creating output file")?,
                        );
                        bincode::serialize_into(out_file, share)
                            .context("while serializing witness share")?;
                        tracing::info!("Wrote witness share {} to file {}", i, path.display());
                    }
                }
            }
            tracing::info!("Split witness into shares successfully")
        }
        Commands::SplitInput {
            config: _,
            input,
            circuit,
            link_library,
            protocol,
            curve: _,
            out_dir,
        } => {
            // verify that protocol is set in args or config
            let protocol = protocol
                .or(cfg.protocol)
                .context("protocol required for this command")?;

            if protocol != MPCProtocol::REP3 {
                return Err(eyre!(
                    "Only REP3 protocol is supported for splitting inputs"
                ));
            }
            file_utils::check_file_exists(&input)?;
            let circuit_path = PathBuf::from(&circuit);
            file_utils::check_file_exists(&circuit_path)?;
            file_utils::check_dir_exists(&out_dir)?;

            let compiler_config = cfg.compiler.context("expected a compiler config")?;

            //get the public inputs if any from parser
            let mut builder = CompilerBuilder::<P>::new(compiler_config, circuit);
            for lib in link_library {
                builder = builder.link_library(lib);
            }
            let public_inputs = builder.build().get_public_inputs()?;

            // read the input file
            let input_file =
                BufReader::new(File::open(&input).context("while opening input file")?);

            let input_json: serde_json::Map<String, serde_json::Value> =
                serde_json::from_reader(input_file).context("while parsing input file")?;

            // create input shares
            let mut shares = [
                SharedInput::<Rep3Protocol<P::ScalarField, Rep3MpcNet>, P>::default(),
                SharedInput::<Rep3Protocol<P::ScalarField, Rep3MpcNet>, P>::default(),
                SharedInput::<Rep3Protocol<P::ScalarField, Rep3MpcNet>, P>::default(),
            ];

            let mut rng = rand::thread_rng();
            for (name, val) in input_json {
                let parsed_vals = if val.is_array() {
                    parse_array(&val)?
                } else {
                    vec![parse_field(&val)?]
                };
                if public_inputs.contains(&name) {
                    shares[0]
                        .public_inputs
                        .insert(name.clone(), parsed_vals.clone());
                    shares[1]
                        .public_inputs
                        .insert(name.clone(), parsed_vals.clone());
                    shares[2].public_inputs.insert(name.clone(), parsed_vals);
                } else {
                    let [share0, share1, share2] =
                        rep3::utils::share_field_elements(&parsed_vals, &mut rng);
                    shares[0].shared_inputs.insert(name.clone(), share0);
                    shares[1].shared_inputs.insert(name.clone(), share1);
                    shares[2].shared_inputs.insert(name.clone(), share2);
                }
            }

            // write out the shares to the output directory
            let base_name = input
                .file_name()
                .context("we have a file name")?
                .to_str()
                .context("input file name is not valid UTF-8")?;
            for (i, share) in shares.iter().enumerate() {
                let path = out_dir.join(format!("{}.{}.shared", base_name, i));
                let out_file =
                    BufWriter::new(File::create(&path).context("while creating output file")?);
                bincode::serialize_into(out_file, share)
                    .context("while serializing witness share")?;
                tracing::info!("Wrote input share {} to file {}", i, path.display());
            }
            tracing::info!("Split input into shares successfully")
        }
        Commands::MergeInputShares {
            config: _,
            inputs,
            protocol,
            curve: _,
            out,
        } => {
            if inputs.len() < 2 {
                return Err(eyre!("Need at least two input shares to merge"));
            }
            for input in &inputs {
                file_utils::check_file_exists(input)?;
            }

            // verify that protocol is set in args or config
            let protocol = protocol
                .or(cfg.protocol)
                .context("protocol required for this command")?;

            match protocol {
                MPCProtocol::REP3 => {
                    merge_input_shares::<P, Rep3Protocol<P::ScalarField, Rep3MpcNet>>(inputs, out)?;
                }
                MPCProtocol::SHAMIR => {
                    merge_input_shares::<P, ShamirProtocol<P::ScalarField, ShamirMpcNet>>(
                        inputs, out,
                    )?;
                }
            }
        }
        Commands::GenerateWitness {
            config: _,
            input,
            circuit,
            link_library,
            protocol,
            curve: _,
            out,
        } => {
            // verify that protocol is set in args or config
            let protocol = protocol
                .or(cfg.protocol)
                .context("protocol required for this command")?;

            if protocol != MPCProtocol::REP3 {
                return Err(eyre!(
                    "Only REP3 protocol is supported for merging input shares"
                ));
            }
            file_utils::check_file_exists(&input)?;
            let circuit_path = PathBuf::from(&circuit);
            file_utils::check_file_exists(&circuit_path)?;

            // parse input shares
            let input_share_file =
                BufReader::new(File::open(&input).context("while opening input share file")?);
            let input_share = collaborative_circom::parse_shared_input(input_share_file)?;

            let result_witness_share = collaborative_circom::generate_witness_rep3::<P>(
                circuit,
                link_library,
                input_share,
                cfg,
            )?;
            // write result to output file
            let out_file = BufWriter::new(std::fs::File::create(&out)?);
            bincode::serialize_into(out_file, &result_witness_share)?;
            tracing::info!("Witness successfully written to {}", out.display());
        }
        Commands::TranslateWitness {
            config: _,
            witness,
            src_protocol,
            target_protocol,
            curve: _,
            out,
        } => {
            if src_protocol != MPCProtocol::REP3 || target_protocol != MPCProtocol::SHAMIR {
                return Err(eyre!("Only REP3 to SHAMIR translation is supported"));
            }
            file_utils::check_file_exists(&witness)?;

            let network_config = cfg.network.context("expected network config")?;

            // parse witness shares
            let witness_file =
                BufReader::new(File::open(witness).context("trying to open witness share file")?);
            let witness_share: SharedWitness<Rep3Protocol<P::ScalarField, Rep3MpcNet>, P> =
                collaborative_circom::parse_witness_share(witness_file)?;

            // connect to network
            let net = Rep3MpcNet::new(network_config)?;

            // init MPC protocol
            let protocol = Rep3Protocol::new(net)?;
            let mut protocol = protocol.get_shamir_protocol()?;

            // Translate witness to shamir shares
            let shamir_witness_share: SharedWitness<
                ShamirProtocol<P::ScalarField, ShamirMpcNet>,
                P,
            > = SharedWitness {
                public_inputs: witness_share.public_inputs,
                witness: protocol.translate_primefield_repshare_vec(witness_share.witness)?,
            };
            // write result to output file
            let out_file = BufWriter::new(std::fs::File::create(&out)?);
            bincode::serialize_into(out_file, &shamir_witness_share)?;
            tracing::info!("Witness successfully written to {}", out.display());
        }
        Commands::GenerateProof {
            proofsystem,
            config: _,
            witness,
            zkey,
            protocol,
            curve: _,
            out,
            public_input: public_input_filename,
            threshold: t,
        } => {
            file_utils::check_file_exists(&witness)?;
            file_utils::check_file_exists(&zkey)?;

            let network_config = cfg.network.context("expected a network config")?;

            // verify that protocol is set in args or config
            let protocol = protocol
                .or(cfg.protocol)
                .context("protocol required for this command")?;

            // parse witness shares
            let witness_file =
                BufReader::new(File::open(witness).context("trying to open witness share file")?);

            // parse Circom zkey file
            let zkey_file = File::open(zkey)?;

            let public_input = match proofsystem {
                ProofSystem::Groth16 => {
                    let (pk, matrices) = Groth16ZKey::<P>::from_reader(zkey_file).unwrap().split();

                    let (proof, public_input) = match protocol {
                        MPCProtocol::REP3 => {
                            if t != 1 {
                                return Err(eyre!("REP3 only allows the threshold to be 1"));
                            }

                            let witness_share =
                                collaborative_circom::parse_witness_share(witness_file)?;
                            let public_input = witness_share.public_inputs.clone();
                            // connect to network
                            let net = Rep3MpcNet::new(network_config)?;

                            // init MPC protocol
                            let protocol = Rep3Protocol::new(net)?;

                            let mut prover = CollaborativeGroth16::new(protocol);

                            // execute prover in MPC
                            let proof =
                                prover.prove_with_matrices(&pk, &matrices, witness_share)?;
                            (proof, public_input)
                        }
                        MPCProtocol::SHAMIR => {
                            let witness_share =
                                collaborative_circom::parse_witness_share(witness_file)?;
                            let public_input = witness_share.public_inputs.clone();

                            // connect to network
                            let net = ShamirMpcNet::new(network_config)?;

                            // init MPC protocol
                            let protocol = ShamirProtocol::new(t, net)?;

                            let mut prover = CollaborativeGroth16::new(protocol);

                            // execute prover in MPC
                            let proof =
                                prover.prove_with_matrices(&pk, &matrices, witness_share)?;
                            (proof, public_input)
                        }
                    };

                    // write result to output file
                    if let Some(out) = out {
                        let out_file = BufWriter::new(
                            std::fs::File::create(&out).context("while creating output file")?,
                        );

                        serde_json::to_writer(out_file, &Groth16JsonProof::<P>::from(proof))
                            .context("while serializing proof to JSON file")?;
                        tracing::info!("Wrote proof to file {}", out.display());
                    }
                    public_input
                }
                ProofSystem::Plonk => {
                    let pk = PlonkZKey::<P>::from_reader(zkey_file).unwrap();

                    let (proof, public_input) = match protocol {
                        MPCProtocol::REP3 => {
                            if t != 1 {
                                return Err(eyre!("REP3 only allows the threshold to be 1"));
                            }

                            let witness_share =
                                collaborative_circom::parse_witness_share(witness_file)?;
                            let public_input = witness_share.public_inputs.clone();
                            // connect to network
                            let net = Rep3MpcNet::new(network_config)?;

                            // init MPC protocol
                            let protocol = Rep3Protocol::new(net)?;

                            let prover = CollaborativePlonk::new(protocol);

                            // execute prover in MPC
                            let proof = prover.prove(pk, witness_share)?;
                            (proof, public_input)
                        }
                        MPCProtocol::SHAMIR => {
                            let witness_share =
                                collaborative_circom::parse_witness_share(witness_file)?;
                            let public_input = witness_share.public_inputs.clone();

                            // connect to network
                            let net = ShamirMpcNet::new(network_config)?;

                            // init MPC protocol
                            let protocol = ShamirProtocol::new(t, net)?;

                            let prover = CollaborativePlonk::new(protocol);

                            // execute prover in MPC
                            let proof = prover.prove(pk, witness_share)?;
                            (proof, public_input)
                        }
                    };

                    // write result to output file
                    if let Some(out) = out {
                        let out_file = BufWriter::new(
                            std::fs::File::create(&out).context("while creating output file")?,
                        );

                        serde_json::to_writer(out_file, &proof)
                            .context("while serializing proof to JSON file")?;
                        tracing::info!("Wrote proof to file {}", out.display());
                    }
                    public_input
                }
            };

            // write public input to output file
            if let Some(public_input_filename) = public_input_filename {
                let public_input_as_strings = public_input
                    .iter()
                    .skip(1) // we skip the constant 1 at position 0
                    .map(|f| {
                        if f.is_zero() {
                            "0".to_string()
                        } else {
                            f.to_string()
                        }
                    })
                    .collect::<Vec<String>>();
                let public_input_file = BufWriter::new(
                    std::fs::File::create(&public_input_filename)
                        .context("while creating public input file")?,
                );
                serde_json::to_writer(public_input_file, &public_input_as_strings)
                    .context("while writing out public inputs to JSON file")?;
                tracing::info!(
                    "Wrote public inputs to file {}",
                    public_input_filename.display()
                );
            }
            tracing::info!("Proof generation finished successfully")
        }
        Commands::Verify {
            proofsystem,
            config: _,
            proof,
            curve: _,
            vk,
            public_input,
        } => {
            file_utils::check_file_exists(&proof)?;
            file_utils::check_file_exists(&vk)?;
            file_utils::check_file_exists(&public_input)?;

            // parse Circom proof file
            let proof_file =
                BufReader::new(File::open(&proof).context("while opening proof file")?);

            // parse Circom verification key file
            let vk_file =
                BufReader::new(File::open(&vk).context("while opening verification key file")?);

            // parse public inputs
            let public_inputs_file = BufReader::new(
                File::open(&public_input).context("while opening public inputs file")?,
            );
            let public_inputs_as_strings: Vec<String> = serde_json::from_reader(public_inputs_file)
                .context("while parsing public inputs, expect them to be array of stringified field elements")?;
            // skip 1 atm
            let public_inputs = public_inputs_as_strings
                .into_iter()
                .map(|s| {
                    s.parse::<P::ScalarField>()
                        .map_err(|_| eyre!("could not parse as field element: {}", s))
                })
                .collect::<Result<Vec<P::ScalarField>, _>>()
                .context("while converting public input strings to field elements")?;

            // verify proof
            let res = match proofsystem {
                ProofSystem::Groth16 => {
                    let proof: Groth16JsonProof<P> = serde_json::from_reader(proof_file)
                        .context("while deserializing proof from file")?;
                    let proof = Groth16Proof::<P>::from(proof);

                    let vk: Groth16JsonVerificationKey<P> = serde_json::from_reader(vk_file)
                        .context("while deserializing verification key from file")?;

                    Groth16::<P>::verify_proof(&vk.into(), &proof, &public_inputs)
                        .context("while verifying proof")?
                }
                ProofSystem::Plonk => {
                    let proof: PlonkProof<P> = serde_json::from_reader(proof_file)
                        .context("while deserializing proof from file")?;

                    let vk: PlonkJsonVerificationKey<P> = serde_json::from_reader(vk_file)
                        .context("while deserializing verification key from file")?;

                    Plonk::<P>::verify(&vk, &proof, &public_inputs)
                        .context("while verifying proof")?
                }
            };

            if res {
                tracing::info!("Proof verified successfully");
            } else {
                tracing::error!("Proof verification failed");
                return Ok(ExitCode::FAILURE);
            }
        }
    }

    Ok(ExitCode::SUCCESS)
}

fn parse_field<F>(val: &serde_json::Value) -> color_eyre::Result<F>
where
    F: std::str::FromStr + PrimeField,
{
    let s = val.as_str().ok_or_else(|| {
        eyre!(
            "expected input to be a field element string, got \"{}\"",
            val
        )
    })?;
    let (is_negative, stripped) = if let Some(stripped) = s.strip_prefix('-') {
        (true, stripped)
    } else {
        (false, s)
    };
    let positive_value = if let Some(stripped) = stripped.strip_prefix("0x") {
        let big_int = BigUint::from_str_radix(stripped, 16)
            .map_err(|_| eyre!("could not parse field element: \"{}\"", val))
            .context("while parsing field element")?;
        let big_int: F::BigInt = big_int
            .try_into()
            .map_err(|_| eyre!("could not parse field element: \"{}\"", val))
            .context("while parsing field element")?;
        F::from(big_int)
    } else {
        stripped
            .parse::<F>()
            .map_err(|_| eyre!("could not parse field element: \"{}\"", val))
            .context("while parsing field element")?
    };
    if is_negative {
        Ok(-positive_value)
    } else {
        Ok(positive_value)
    }
}

fn parse_array<F: PrimeField>(val: &serde_json::Value) -> color_eyre::Result<Vec<F>> {
    let json_arr = val.as_array().expect("is an array");
    let mut field_elements = vec![];
    for ele in json_arr {
        if ele.is_array() {
            field_elements.extend(parse_array::<F>(ele)?);
        } else {
            field_elements.push(parse_field(ele)?);
        }
    }
    Ok(field_elements)
}

fn merge_input_shares<P: Pairing, T: PrimeFieldMpcProtocol<P::ScalarField>>(
    inputs: Vec<PathBuf>,
    out: PathBuf,
) -> color_eyre::Result<()> {
    let mut input_shares = inputs
        .iter()
        .map(|input| {
            let input_share_file =
                BufReader::new(File::open(input).context("while opening input share file")?);
            let input_share: SharedInput<T, P> = bincode::deserialize_from(input_share_file)
                .context("trying to parse input share file")?;
            color_eyre::Result::<_>::Ok(input_share)
        })
        .collect::<Result<Vec<_>, _>>()?;
    let start = input_shares.pop().expect("we have at least two inputs");
    let merged = input_shares.into_iter().try_fold(start, |a, b| {
        a.merge(b).context("while merging input shares")
    })?;

    let out_file = BufWriter::new(File::create(&out).context("while creating output file")?);
    bincode::serialize_into(out_file, &merged).context("while serializing witness share")?;
    tracing::info!("Wrote merged input share to file {}", out.display());
    Ok(())
}

use clap::Parser;
use color_eyre::eyre::{eyre, Context, Ok};
use std::io::Write;
use std::path::Path;
use std::sync::mpsc::channel;
use std::time::Duration;
use std::{
    fs::File, io::BufWriter, path::PathBuf, process::Command, process::ExitCode, thread,
    time::Instant,
};

use collaborative_circom::file_utils::{check_dir_exists, check_file_exists};

fn install_tracing() {
    use tracing_subscriber::prelude::*;
    use tracing_subscriber::{fmt, EnvFilter};

    let fmt_layer = fmt::layer().with_target(true).with_line_number(true);
    let filter_layer = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .init();
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
/// Generates and verifies a proof for a given circuit using snarkjs and co-circom. Measures prover and verifier time.
struct Cli {
    /// The path to the proving key (.zkey) file, generated by snarkjs setup phase
    #[arg(long)]
    zkey: PathBuf,
    /// The path to the witness file
    #[arg(long)]
    witness: PathBuf,
    /// The path to the r1cs file, generated by Circom compiler
    #[arg(long)]
    r1cs: PathBuf,
    /// The path to the data directory containing the certificates and keys for the parties
    #[arg(long, default_value = "collaborative-circom/examples/data")]
    data: PathBuf,
    /// The path to the co_circom binary
    #[arg(long, default_value = "co_circom")]
    co_circom_bin: String,
    /// The path to the snarkjs binary
    #[arg(long, default_value = "snarkjs")]
    snarkjs_bin: String,
    /// The TCP port of party 1
    #[arg(long, default_value = "10000")]
    p1_port: u16,
    /// The TCP port of party 2
    #[arg(long, default_value = "10001")]
    p2_port: u16,
    /// The TCP port of party 3
    #[arg(long, default_value = "10002")]
    p3_port: u16,
    /// Keep intermediate output files
    #[arg(long, default_value = "false")]
    keep_artifacts: bool,
    /// Intermediate output: The path to the verification key file
    #[arg(long, default_value = "verification_key.json")]
    vkey: PathBuf,
    /// Intermediate output: The path to the public input file for the snarkjs execution
    #[arg(long, default_value = "public_input_snarkjs.json")]
    pub_inp_sjs: PathBuf,
    /// Intermediate output: The path to the proof file for the snarkjs execution
    #[arg(long, default_value = "proof_snarkjs.json")]
    proof_sjs: PathBuf,
    /// Intermediate output: The path to the public input file 1 for the co-circom execution
    #[arg(long, default_value = "public_input_co_circom_0.json")]
    pub_inp_coc_1: PathBuf,
    /// Intermediate output: The path to the public input file 2 for the co-circom execution
    #[arg(long, default_value = "public_input_co_circom_1.json")]
    pub_inp_coc_2: PathBuf,
    /// Intermediate output: The path to the public input file 3 for the co-circom execution
    #[arg(long, default_value = "public_input_co_circom_2.json")]
    pub_inp_coc_3: PathBuf,
    /// Intermediate output: The path to the proof file 1 for the co-circom execution
    #[arg(long, default_value = "proof_co_circom_0.json")]
    proof_coc_1: PathBuf,
    /// Intermediate output: The path to the proof file 2 for the co-circom execution
    #[arg(long, default_value = "proof_co_circom_1.json")]
    proof_coc_2: PathBuf,
    /// Intermediate output: The path to the proof file 3 for the co-circom execution
    #[arg(long, default_value = "proof_co_circom_2.json")]
    proof_coc_3: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 1 for the co-circom execution
    #[arg(long, default_value = "party0.toml")]
    p1_toml: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 2 for the co-circom execution
    #[arg(long, default_value = "party1.toml")]
    p2_toml: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 3 for the co-circom execution
    #[arg(long, default_value = "party2.toml")]
    p3_toml: PathBuf,
}

// filenames for certificates and keys inside the data directory
static PARTY_1_CERT_FILENAME: &str = "cert0.der";
static PARTY_2_CERT_FILENAME: &str = "cert1.der";
static PARTY_3_CERT_FILENAME: &str = "cert2.der";
static PARTY_1_KEY_FILENAME: &str = "key0.der";
static PARTY_2_KEY_FILENAME: &str = "key1.der";
static PARTY_3_KEY_FILENAME: &str = "key2.der";

#[derive(Debug, Clone)]
struct Config {
    zkey: PathBuf,
    witness: PathBuf,
    witness_path: PathBuf,
    r1cs: PathBuf,
    data: PathBuf,
    co_circom_bin: String,
    snarkjs_bin: String,
    p1_port: u16,
    p2_port: u16,
    p3_port: u16,
    keep_artifacts: bool,
    vkey: PathBuf,
    pub_inp_sjs: PathBuf,
    proof_sjs: PathBuf,
    p1_cert: PathBuf,
    p2_cert: PathBuf,
    p3_cert: PathBuf,
    p1_key: PathBuf,
    p2_key: PathBuf,
    p3_key: PathBuf,
    wtns_shr_1: PathBuf,
    wtns_shr_2: PathBuf,
    wtns_shr_3: PathBuf,
    proof_coc_1: PathBuf,
    proof_coc_2: PathBuf,
    proof_coc_3: PathBuf,
    pub_inp_coc_1: PathBuf,
    pub_inp_coc_2: PathBuf,
    pub_inp_coc_3: PathBuf,
    p1_toml: PathBuf,
    p2_toml: PathBuf,
    p3_toml: PathBuf,
}

impl From<Cli> for Config {
    fn from(cli: Cli) -> Self {
        let p1_cert = cli.data.join(PARTY_1_CERT_FILENAME);
        let p2_cert = cli.data.join(PARTY_2_CERT_FILENAME);
        let p3_cert = cli.data.join(PARTY_3_CERT_FILENAME);
        let p1_key = cli.data.join(PARTY_1_KEY_FILENAME);
        let p2_key = cli.data.join(PARTY_2_KEY_FILENAME);
        let p3_key = cli.data.join(PARTY_3_KEY_FILENAME);
        let witness_path = {
            let tmp = cli.witness.parent().expect("witness file has no parent");
            if tmp
                .to_str()
                .expect("witness file path is not valid utf-8")
                .is_empty()
            {
                PathBuf::from(".")
            } else {
                PathBuf::from(tmp)
            }
        };
        let witness_name = cli
            .witness
            .file_name()
            .expect("we have a file name")
            .to_str()
            .expect("witness file name is not valid UTF-8");
        let wtns_shr_1 = witness_path.join(Path::new(&format!("{}.{}.shared", witness_name, 0)));
        let wtns_shr_2 = witness_path.join(Path::new(&format!("{}.{}.shared", witness_name, 1)));
        let wtns_shr_3 = witness_path.join(Path::new(&format!("{}.{}.shared", witness_name, 2)));

        Config {
            zkey: cli.zkey,
            witness: cli.witness,
            witness_path,
            r1cs: cli.r1cs,
            data: cli.data,
            co_circom_bin: cli.co_circom_bin,
            snarkjs_bin: cli.snarkjs_bin,
            p1_port: cli.p1_port,
            p2_port: cli.p2_port,
            p3_port: cli.p3_port,
            keep_artifacts: cli.keep_artifacts,
            vkey: cli.vkey,
            pub_inp_sjs: cli.pub_inp_sjs,
            proof_sjs: cli.proof_sjs,
            p1_cert,
            p2_cert,
            p3_cert,
            p1_key,
            p2_key,
            p3_key,
            wtns_shr_1,
            wtns_shr_2,
            wtns_shr_3,
            proof_coc_1: cli.proof_coc_1,
            proof_coc_2: cli.proof_coc_2,
            proof_coc_3: cli.proof_coc_3,
            pub_inp_coc_1: cli.pub_inp_coc_1,
            pub_inp_coc_2: cli.pub_inp_coc_2,
            pub_inp_coc_3: cli.pub_inp_coc_3,
            p1_toml: cli.p1_toml,
            p2_toml: cli.p2_toml,
            p3_toml: cli.p3_toml,
        }
    }
}

struct BenchResult {
    prove: Duration,
    verify: Duration,
}

impl std::fmt::Display for BenchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Prover Time: {:?}, Verifier Time: {:?}",
            self.prove, self.verify
        )
    }
}

fn bench_snarkjs(conf: &Config) -> color_eyre::Result<BenchResult> {
    tracing::trace!("Starting snarkjs benching ..");
    tracing::trace!("Starting snarkjs prover ..");
    let now = Instant::now();
    let out_prove = Command::new(&conf.snarkjs_bin)
        .arg("groth16")
        .arg("prove")
        .arg(conf.zkey.as_path())
        .arg(conf.witness.as_path())
        .arg(conf.proof_sjs.as_path())
        .arg(conf.pub_inp_sjs.as_path())
        .output()
        .context("during executing \"snarkjs groth16 prove\"")?;
    let prover_time = now.elapsed();
    if !out_prove.status.success() {
        tracing::error!(
            "Failed to create proof using snarkjs: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_prove.stdout)?,
            std::str::from_utf8(&out_prove.stderr)?
        );
        return Err(eyre!("Failed to create proof using snarkjs"));
    }

    tracing::trace!("Starting snarkjs verifier ..");
    let now = Instant::now();
    let out_prove = Command::new(&conf.snarkjs_bin)
        .arg("groth16")
        .arg("verify")
        .arg(conf.vkey.as_path())
        .arg(conf.pub_inp_sjs.as_path())
        .arg(conf.proof_sjs.as_path())
        .output()
        .context("during executing \"snarkjs groth16 verify\"")?;
    let verifier_time = now.elapsed();
    if !out_prove.status.success() {
        tracing::error!(
            "Failed to verify proof using snarkjs: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_prove.stdout)?,
            std::str::from_utf8(&out_prove.stderr)?
        );
        return Err(eyre!("Failed to verify proof using snarkjs"));
    }
    Ok(BenchResult {
        prove: prover_time,
        verify: verifier_time,
    })
}

fn create_party_toml_files(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Creating party TOML files ..");
    let general_toml = format!(
        r#"[[parties]]
id = 0
dns_name = "localhost:{}"
cert_path = "{}"
[[parties]]
id = 1
dns_name = "localhost:{}"
cert_path = "{}"
[[parties]]
id = 2
dns_name = "localhost:{}"
cert_path = "{}"
"#,
        conf.p1_port,
        conf.p1_cert.to_str().unwrap(),
        conf.p2_port,
        conf.p2_cert.to_str().unwrap(),
        conf.p3_port,
        conf.p3_cert.to_str().unwrap(),
    );
    let party1_toml = format!(
        r#"my_id = 0
bind_addr = "0.0.0.0:{}"
key_path = "{}"
{}"#,
        conf.p1_port,
        conf.p1_key.to_str().unwrap(),
        general_toml
    );
    let party2_toml = format!(
        r#"my_id = 1
bind_addr = "0.0.0.0:{}"
key_path = "{}"
{}"#,
        conf.p2_port,
        conf.p2_key.to_str().unwrap(),
        general_toml
    );
    let party3_toml = format!(
        r#"my_id = 2
bind_addr = "0.0.0.0:{}"
key_path = "{}"
{}"#,
        conf.p3_port,
        conf.p3_key.to_str().unwrap(),
        general_toml
    );
    let mut out_file =
        BufWriter::new(File::create(&conf.p1_toml).context("while creating output file")?);
    out_file
        .write_all(party1_toml.as_bytes())
        .context("trying to write to file")?;
    let mut out_file =
        BufWriter::new(File::create(&conf.p2_toml).context("while creating output file")?);
    out_file
        .write_all(party2_toml.as_bytes())
        .context("trying to write to file")?;
    let mut out_file =
        BufWriter::new(File::create(&conf.p3_toml).context("while creating output file")?);
    out_file
        .write_all(party3_toml.as_bytes())
        .context("trying to write to file")?;
    Ok(())
}

fn bench_co_circom_prover(conf: &Config) -> color_eyre::Result<Duration> {
    tracing::trace!("Starting party 1 prover ..");
    let (tx_1, rx_1) = channel();
    let tmp_conf = conf.clone();
    thread::spawn(move || {
        let conf = tmp_conf;
        let now = Instant::now();
        let out_co_circom_prove_1 = Command::new(&conf.co_circom_bin)
            .arg("generate-proof")
            .arg("--witness")
            .arg(conf.wtns_shr_1.as_path())
            .arg("--zkey")
            .arg(conf.zkey.as_path())
            .arg("--protocol")
            .arg("not_required_yet")
            .arg("--config")
            .arg(conf.p1_toml.as_path())
            .arg("--out")
            .arg(conf.proof_coc_1.as_path())
            .arg("--public-input")
            .arg(conf.pub_inp_coc_1.as_path())
            .output()
            .context("during executing \"co-circom generate-proof\" for party 1")?;
        let prover_time = now.elapsed();
        if !out_co_circom_prove_1.status.success() {
            tracing::error!(
                "Failed to generate proof for party 1: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_co_circom_prove_1.stdout)?,
                std::str::from_utf8(&out_co_circom_prove_1.stderr)?
            );
            return Err(eyre!("Failed to generate proof for party 1"));
        }
        tx_1.send(prover_time).unwrap();
        Ok(())
    });

    tracing::trace!("Starting party 2 prover ..");
    let (tx_2, rx_2) = channel();
    let tmp_conf = conf.clone();
    thread::spawn(move || {
        let conf = tmp_conf;
        let now = Instant::now();
        let out_co_circom_prove_2 = Command::new(&conf.co_circom_bin)
            .arg("generate-proof")
            .arg("--witness")
            .arg(conf.wtns_shr_2.as_path())
            .arg("--zkey")
            .arg(conf.zkey.as_path())
            .arg("--protocol")
            .arg("not_required_yet")
            .arg("--config")
            .arg(conf.p2_toml.as_path())
            .arg("--out")
            .arg(conf.proof_coc_2.as_path())
            .arg("--public-input")
            .arg(conf.pub_inp_coc_2.as_path())
            .output()
            .context("during executing \"co-circom generate-proof\" for party 2")?;
        let prover_time = now.elapsed();
        if !out_co_circom_prove_2.status.success() {
            tracing::error!(
                "Failed to generate proof for party 2: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_co_circom_prove_2.stdout)?,
                std::str::from_utf8(&out_co_circom_prove_2.stderr)?
            );
            return Err(eyre!("Failed to generate proof for party 2"));
        }
        tx_2.send(prover_time).unwrap();
        Ok(())
    });

    tracing::trace!("Starting party 3 prover ..");
    let (tx_3, rx_3) = channel();
    let tmp_conf = conf.clone();
    thread::spawn(move || {
        let conf = tmp_conf;
        let now = Instant::now();
        let out_co_circom_prove_3 = Command::new(&conf.co_circom_bin)
            .arg("generate-proof")
            .arg("--witness")
            .arg(conf.wtns_shr_3.as_path())
            .arg("--zkey")
            .arg(conf.zkey.as_path())
            .arg("--protocol")
            .arg("not_required_yet")
            .arg("--config")
            .arg(conf.p3_toml.as_path())
            .arg("--out")
            .arg(conf.proof_coc_3.as_path())
            .arg("--public-input")
            .arg(conf.pub_inp_coc_3.as_path())
            .output()
            .context("during executing \"co-circom generate-proof\" for party 3")?;
        let prover_time = now.elapsed();
        if !out_co_circom_prove_3.status.success() {
            tracing::error!(
                "Failed to generate proof for party 3: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_co_circom_prove_3.stdout)?,
                std::str::from_utf8(&out_co_circom_prove_3.stderr)?
            );
            return Err(eyre!("Failed to generate proof for party 3"));
        }
        tx_3.send(prover_time).unwrap();
        Ok(())
    });

    let res_1 = rx_1.recv().unwrap();
    let res_2 = rx_2.recv().unwrap();
    let res_3 = rx_3.recv().unwrap();

    tracing::debug!("Prover time party 1: {:?}", res_1);
    tracing::debug!("Prover time party 2: {:?}", res_2);
    tracing::debug!("Prover time party 3: {:?}", res_3);

    Ok(std::cmp::min(res_1, std::cmp::min(res_2, res_3)))
}

fn bench_co_circom(conf: &Config) -> color_eyre::Result<BenchResult> {
    tracing::trace!("Starting co-circom benching ..");
    tracing::trace!("Splitting witness ..");
    let out_co_circom_split_witness = Command::new(&conf.co_circom_bin)
        .arg("split-witness")
        .arg("--witness")
        .arg(conf.witness.as_path())
        .arg("--r1cs")
        .arg(conf.r1cs.as_path())
        .arg("--protocol")
        .arg("not_required_yet")
        .arg("--out-dir")
        .arg(conf.witness_path.as_path())
        .output()
        .context("during executing \"co-circom split-witness\"")?;
    if !out_co_circom_split_witness.status.success() {
        tracing::error!(
            "Failed to split witness: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_co_circom_split_witness.stdout)?,
            std::str::from_utf8(&out_co_circom_split_witness.stderr)?
        );
        return Err(eyre!("Failed to split witness"));
    }

    create_party_toml_files(conf).context("during creating party toml files")?;

    let prover_time = bench_co_circom_prover(conf).context("during benching co-circom prover")?;

    tracing::trace!("Starting verifier ..");
    // co-circom verify --proof proof.0.json --vk test_vectors/multiplier2/verification_key.json --public-input public_input.json
    let now = Instant::now();
    let out_co_circom_verifier = Command::new(&conf.co_circom_bin)
        .arg("verify")
        .arg("--proof")
        .arg(conf.proof_coc_1.as_path())
        .arg("--vk")
        .arg(conf.vkey.as_path())
        .arg("--public-input")
        .arg(conf.pub_inp_coc_1.as_path())
        .output()
        .context("during executing \"co-circom verify\"")?;
    let verifier_time = now.elapsed();
    if !out_co_circom_verifier.status.success() {
        tracing::error!(
            "Failed to verify proof: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_co_circom_verifier.stdout)?,
            std::str::from_utf8(&out_co_circom_verifier.stderr)?
        );
        return Err(eyre!("Failed to verify proof"));
    }

    Ok(BenchResult {
        prove: prover_time,
        verify: verifier_time,
    })
}

fn prepare(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Exporting verification key ..");
    let out_snarkjs = Command::new("snarkjs")
        .arg("zkey")
        .arg("export")
        .arg("verificationkey")
        .arg(conf.zkey.as_path())
        .arg(conf.vkey.as_path())
        .output()
        .context("during executing \"snarkjs zkey export\"")?;
    if !out_snarkjs.status.success() {
        tracing::error!(
            "Failed to export verification key: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_snarkjs.stdout)?,
            std::str::from_utf8(&out_snarkjs.stderr)?
        );
        return Err(eyre!("Failed to export verification key"));
    }
    Ok(())
}

fn check_args(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Checking args ..");
    check_file_exists(&conf.zkey).context("checking existence of zkey file")?;
    check_file_exists(&conf.witness).context("checking existence of witness file")?;
    check_file_exists(&conf.r1cs).context("checking existence of r1cs file")?;
    check_dir_exists(&conf.data).context("checking existence of data directory")?;
    check_file_exists(&conf.p1_cert).context("checking existence of party 1 certificate")?;
    check_file_exists(&conf.p2_cert).context("checking existence of party 2 certificate")?;
    check_file_exists(&conf.p3_cert).context("checking existence of party 3 certificate")?;
    check_file_exists(&conf.p1_key).context("checking existence of party 1 key")?;
    check_file_exists(&conf.p2_key).context("checking existence of party 2 key")?;
    check_file_exists(&conf.p3_key).context("checking existence of party 3 key")?;
    let out_co_circom_check = Command::new("which")
        .arg(&conf.co_circom_bin)
        .output()
        .context("during checking existence of co_circom binary")?;
    if !out_co_circom_check.status.success() {
        return Err(eyre!(
            "co-circom executable not found: {}",
            &conf.co_circom_bin
        ));
    }
    let out_snarkjs_check = Command::new("which")
        .arg(&conf.snarkjs_bin)
        .output()
        .context("during checking existence of snarkjs binary")?;
    if !out_snarkjs_check.status.success() {
        return Err(eyre!("snarkjs executable not found: {}", conf.snarkjs_bin));
    }
    Ok(())
}

fn run_artifacts(conf: &Config) -> color_eyre::Result<ExitCode> {
    prepare(conf).context("during preparation")?;
    let circom_results = bench_snarkjs(conf).context("during benching circom")?;
    tracing::info!("Results circom: {}", circom_results);
    let co_circom_results = bench_co_circom(conf).context("during benching co_circom")?;
    tracing::info!("Results co-circom: {}", co_circom_results);
    Ok(ExitCode::SUCCESS)
}

fn cleanup(conf: &Config) -> color_eyre::Result<()> {
    if conf.keep_artifacts {
        return Ok(());
    }
    tracing::trace!("Cleaning up artifacts ..");
    if check_file_exists(&conf.vkey).is_ok() {
        std::fs::remove_file(&conf.vkey).context("during removing verification key")?;
    }
    if check_file_exists(&conf.pub_inp_sjs).is_ok() {
        std::fs::remove_file(&conf.pub_inp_sjs)
            .context("during removing public input file for the snarkjs execution")?;
    }
    if check_file_exists(&conf.proof_sjs).is_ok() {
        std::fs::remove_file(&conf.proof_sjs)
            .context("during removing proof file for the snarkjs execution")?;
    }
    if check_file_exists(&conf.wtns_shr_1).is_ok() {
        std::fs::remove_file(&conf.wtns_shr_1)
            .context("during removing party 1 witness share file for the co-circom execution")?;
    }
    if check_file_exists(&conf.wtns_shr_2).is_ok() {
        std::fs::remove_file(&conf.wtns_shr_2)
            .context("during removing party 2 witness share file for the co-circom execution")?;
    }
    if check_file_exists(&conf.wtns_shr_3).is_ok() {
        std::fs::remove_file(&conf.wtns_shr_3)
            .context("during removing party 3 witness share file for the co-circom execution")?;
    }
    if check_file_exists(&conf.proof_coc_1).is_ok() {
        std::fs::remove_file(&conf.proof_coc_1)
            .context("during removing proof file 1 for the co-circom execution")?;
    }
    if check_file_exists(&conf.proof_coc_2).is_ok() {
        std::fs::remove_file(&conf.proof_coc_2)
            .context("during removing proof file 2 for the co-circom execution")?;
    }
    if check_file_exists(&conf.proof_coc_3).is_ok() {
        std::fs::remove_file(&conf.proof_coc_3)
            .context("during removing proof file 3 for the co-circom execution")?;
    }
    if check_file_exists(&conf.pub_inp_coc_1).is_ok() {
        std::fs::remove_file(&conf.pub_inp_coc_1)
            .context("during removing public input file 1 for the co-circom execution")?;
    }
    if check_file_exists(&conf.pub_inp_coc_2).is_ok() {
        std::fs::remove_file(&conf.pub_inp_coc_2)
            .context("during removing public input file 2 for the co-circom execution")?;
    }
    if check_file_exists(&conf.pub_inp_coc_3).is_ok() {
        std::fs::remove_file(&conf.pub_inp_coc_3)
            .context("during removing public input file 3 for the co-circom execution")?;
    }
    if check_file_exists(&conf.p1_toml).is_ok() {
        std::fs::remove_file(&conf.p1_toml).context(
            "during removing party configuration toml file 1 for the co-circom execution",
        )?;
    }
    if check_file_exists(&conf.p2_toml).is_ok() {
        std::fs::remove_file(&conf.p2_toml).context(
            "during removing party configuration toml file 2 for the co-circom execution",
        )?;
    }
    if check_file_exists(&conf.p3_toml).is_ok() {
        std::fs::remove_file(&conf.p3_toml).context(
            "during removing party configuration toml file 3 for the co-circom execution",
        )?;
    }
    Ok(())
}

fn main() -> color_eyre::Result<ExitCode> {
    install_tracing();
    let args = Cli::parse();
    let conf = Config::from(args);
    check_args(&conf).context("during checking arguments")?;
    let result = run_artifacts(&conf);
    cleanup(&conf).context("during cleanup")?;
    result
}

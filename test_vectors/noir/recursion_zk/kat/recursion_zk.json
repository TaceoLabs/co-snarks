{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"2046916047737031822","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":115,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":508,"type":{"kind":"field"}},"visibility":"private"},{"name":"vk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"dZBBDoMgEEXvMmsWFkuTepWmMYijISFAEJo0hrt3NFJ14YZh5vM+mT9Dj10aW20HN0HzmqEL2hg9tsYpGbWzNJ0zg9K2MSDSCA46UV4GtBEam4xh8JEmrY8mL+1aowykVgzQ9lTJcNAGl1tmO11do1yIDa6f4o+LM3+75mv+4MWgvu8OnOf8pk4qHU47Q0UigxudebENWnYGtzSGZNUhnPj1RSnx+eAU9ingYrpq9M0P","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"50":{"source":"global HONK_VK_SIZE: u32 = 115;\nglobal HONK_PROOF_SIZE: u32 = 508;\nglobal HONK_IDENTIFIER: u32 = 7;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    vk_hash: Field,\n    public_inputs: pub [Field; 1],\n) {\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        vk_hash,\n        HONK_IDENTIFIER,\n    );\n}\n","path":"/co-snarks/co-noir/co-noir/examples/test_vectors/recursion_zk/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}
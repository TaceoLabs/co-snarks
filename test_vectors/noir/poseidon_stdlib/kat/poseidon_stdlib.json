{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"5324936693492432509","abi":{"parameters":[{"name":"x1","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"y1","type":{"kind":"field"},"visibility":"public"},{"name":"x2","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"private"},{"name":"y2","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"51":{"source":"use poseidon::poseidon;\n\nfn main(x1: [Field; 2], y1: pub Field, x2: [Field; 4], y2: pub Field) {\n    let hash1 = poseidon::bn254::hash_2(x1);\n    assert(hash1 == y1);\n\n    let hash2 = poseidon::bn254::hash_4(x2);\n    assert(hash2 == y2);\n}\n","path":"/co-snarks/test_vectors/noir/poseidon_stdlib/src/main.nr"},"55":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::poseidon::bn254::consts;\nuse crate::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254/perm.nr"},"56":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/bn254.nr"},"57":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse std::default::Default;\nuse std::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        std::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        std::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    std::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: u32,\n    capacity: u32,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, (rate + capacity) as Field);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n","path":"/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon/mod.nr"}},"expression_width":{"Bounded":{"width":4}}}
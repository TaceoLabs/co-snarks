{"noir_version":"1.0.0-beta.17+0d6984c7c643b690e6559351f0cb36ce62b44b26","hash":"1023734874483577512","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":115,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":457,"type":{"kind":"field"}},"visibility":"private"},{"name":"vk_hash","type":{"kind":"field"},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"dZDRDoMgDEX/pc8+OJjG+CvLYhCrISFAEJYshn9fNeL0wafSXs5tehcYsI9Tp8xoZ2hfC/Reaa2mTlspgrKGpksqILdd8Ig0gpNOlBMeTYDWRK0L+Agdt0+zE2arQXhSywLQDFTJcFQa11cq/nR5j7Kq2mH+bA68elz4xz3PWcOzAa/rw4GxlN7UCan85WYoSUyroVei17jnMEYjT7GEr8tKDs55K3GIHle7TaMFPw==","file_map":{"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nmod primitive_docs;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"51":{"source":"global HONK_VK_SIZE: u32 = 115;\nglobal HONK_PROOF_SIZE: u32 = 457;\nglobal HONK_IDENTIFIER: u32 = 1;\n\nfn main(\n    verification_key: [Field; HONK_VK_SIZE],\n    proof: [Field; HONK_PROOF_SIZE],\n    vk_hash: Field,\n    public_inputs: pub [Field; 1],\n) {\n    std::verify_proof_with_type(verification_key, proof, public_inputs, vk_hash, HONK_IDENTIFIER);\n}\n","path":"/co-snarks/test_vectors/noir/recursion/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}
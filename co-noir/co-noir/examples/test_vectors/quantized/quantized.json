{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":3769298023492767985,"abi":{"parameters":[{"name":"x","type":{"kind":"field"},"visibility":"private"},{"name":"y","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"struct","path":"std::cmp::Ordering","fields":[{"name":"result","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+1dC5hVVdleZ5jhpihXUUEu3sr7WXNm5pzBGyreLyiiiCI6zMwRRZQoUoliLKLIMoowIgkjCjGiCCWKMKIQQ5S8UUQZlfqXl7/6s4tW/u0Ne8M+e9ZZZ1/ed9jL9n6e5RnXYr/nfb/1fevbe5+11s6IPceSKiHyVXv+rnbqMmLf4TSJ4c5nNt4hhQ8vl22oq2vN17bKnGzK1jZOKNRn6+onNBRkQdYX6ltqC7lca6GukG+c0JjPNsq6XKss1jfmig5gxscZxDOLxPJyHOL83cmxd41VOluli1W6WqWbVbpb5QCrHGiVHlY5yCoHW6WnVXpZpbdV+lilr1X6WeUQq/S3yqFWOcwqh1tlgFUGWuUIqwyyymDnu4da5UiXTCfPZ1dfXbWirkZR11lR10VR11VR101R111Rd4Ci7kBFXQ9F3UGKuoMVdT0Vdb0Udb0VdX0UdX0Vdf0UdYco6vor6g5V1B2mqDtcUTdAUTdQUXeEom6Qom6wom6Iom6oou5Ip06I9kEbdzAQJNyjM9iBBTxYSRcTrfsYsG73ONKvX2ZjHZ1KbRkLrdrfLzHQatr3cWS0zkLRFxHRughlv0ZC6yrK+EgEtG6irL+FRusuNL4bEu0AoY2DUGgHigoxFQKth6gYn4HRDqqMFRjt4CBYAdF6BsMKhNYrKFYAtN7BsSqi9QmDVQGtbzgsLVq/sFgatEPCY5VF6x8FqwzaodGwlGiHRcVSoB0eHasd2oA4WD60gfGwStCOiIvlQRsUH2sv2mAEloM2BIO1G20oCstCOxKIBbw+lshrTvtazntdbB/pA434WFUeex7lfB7tknZv9OyGNl/d0U6d96gGG/Co4FjNFbDk0UBe3iBJ0o1ZtRMUVaL8EfS7KtnTi4m+CT4Kh5X1DhjHCJ8THyNKRxThtLGcuALXileqxwB5HYtzhqzXpjZuG9mmyGBG2vRdIWxa6bu8Nn2XY9Nqp/h9Vgh8EB4tOEH4bibhdxNwjwM6CEv3cR4Dg3BLHvP5L7Xi2gFp0+OBtvRqRg9aJyD7PKGX6Uz7nQjESvIVnH10xAAP9Efl76InWeVkq5xi41vFDq5a295WqbNKvVUarJK3SsEqjVYZZpVTrXKaVU63yhlWOdPheZZVzrbKOVYZYZVzrXKeVc63ygVWudAqF1nlYqtc4rUh2nDAAafkysk2mP83tpMVdaco6rKKOqmoq1XU5RR1dYq6ekVdg6Iur6grKOoaFXXDFHWnKupOU9Sdrqg7Q1F3pqJuuKLuLEXd2Yq6cxR1IxR15yrqzlPUna+ou0BRd6Gi7iJF3cWKuktE+d9us/GO3fFxksD/hnmpwCYqhu5LCbovE5zx5jKiD9jfcRzBFiMN8IGRBN2Xk3zgcsEdBxjxUJ/wORwsH2jImHGhfgXQlsC+lkj7eWPoCnIMnUzwpVEi+TE0iqD7SsHxgSuJPmDfFDJy6WgDfGA0QfdVJB+4SnDHAUY85A3IpQwfKBiSS68G2hLY17JAyqVXk2PoFIIvjRHJj6ExBN3XCI4PXEP0AXseLyOXjjXAB8YSdF9L8oFrBXccYMRDowG5lOEDwwzJpdcBbQnsazmMlEuvI8dQluBL40TyY2gcQff1guMD1xN9wF7Hwsil4w3wgfEE3TeQfOAGwR0HGPFwqgG5lOEDpxmSS28E2hLY1/I0Ui69kRxDkuBLTSL5MdRE0D1BcHxgAtEH7HWcjFzabIAPNBN0t5B8oEVwxwFGPJxuQC5l+MAZhuTSVqAtgX0tzyDl0lZyDNUSfKkokh9DRYLumwTHB24i+oCNy8ilEw3wgYkE3TeTfOBmwR0HGPFwpgG5lOEDww3JpbcAbQnsazmclEtvIcdQjuBLk0TyY2gSQfetguMDtxJ9wN7Hh5FLJxvgA5MJum8j+cBtgjsOMOLhLANyKcMHzjYkl94OtCWwr+XZpFx6OzmG6gi+NEUkP4amEHS/R3B84D1EH+guOLl0qgE+MJWg+70kH3iv4I4DjHg4x4BcyvCBEYbk0vcBbQnsazmClEvfR46heoIvTRPJj6FpBN3vFxwfeD/RB+x9XBm59A4DfOAOgu47ST5wp+COA4x4ONeAXMrwgfMMyaV3AW0J7Gt5HimX3kWOoQaCL00XyY+h6QTdHxAcH/gA0QfsfcwZuXSGAT4wg6D7gyQf+KDgjgOMeDjfgFzK8IELDMmlHwLaEtjX8gJSLv0QOYbyBF+aKZIfQzMJutsExwfaiD5gv8eDkUvvNsAH7ibo/jDJBz4suOMAIx4uNCCXMnzgIkNy6UeAtgT2tbyIlEs/Qo6hAsGXZonkx9Asgu6PCo4PfJToA/Z7rBi5dLYBPjCboPtjJB/4mOCOA4x4uNiAXMrwgUsMyaUfB9oS2NfyElIu/Tg5hhoJvjRHJD+G5hB0f0JwfOATRB+w3+PIyKX3GOAD9xB0f5LkA58U3HGAEQ+XGpBLGT5wmSG59FNAWwL7Wl5GyqWfIsfQMIIv3SuSH0P3EnR/WnB84NNEH+gpOLl0rgE+MJeg+zMkH/iM4I4DjHgYaUAuZfjA5Ybk0s8CbQnsa3k5KZd+lhxDpxJ8aZ5IfgzNI+j+nOD4wOeIPtBLcHLpfAN8YD5B930kH7hPcMcBRjxcYUAuZfjAKENy6eeBtgT2tRxFyqWfJ8fQaQRfWiCSH0MLCLq/IDg+8AWiD/QWnFy60AAfWEjQ/UWSD3xRcMcBRjxcaUAuZfjAaENy6f1AWwL7Wo4m5dL7yTF0OsGXFonkx9Aigu4vCY4PfInoA30EJ5cuNsAHFhN0P0DygQcEdxxgxMNVBuRShg9cbUgu/TLQlsC+lleTcumXyTF0BsGXlojkx9ASgu6vCI4PfIXoA30FJ5cuNcAHlhJ0f5XkA18V3HGAEQ9jDMilDB+4xpBc+jWgLYF9La8h5dKvkWPoTIIvLRPJj6FlBN0PCo4PPEj0gX6Ck0uXG+ADywm6HyL5wEOCOw4w4mGsAbmU4QPXGpJLvw60JbCv5bWkXPp1cgwNJ/jSCpH8GFpB0P0NwfGBbxB94BDByaUrDfCBlQTd3yT5wDcFdxxgxMN1BuRShg+MMySXfgtoS2Bfy3GkXPotcgydRfClVSL5MbSKoPvbguMD3yb6QH/ByaWrDfCB1QTdD5N84GHBHQcY8XC9AbmU4QPjDcmljwBtCexrOZ6USx8hx9DZBF9aI5IfQ2sIur8jOD7wHaIPHCo4uXStAT6wlqD7uyQf+K7gjgOMeLjBgFzK8IEbDcml3wPaEtjX8kZSLv0eOYbOIfjSOpH8GFpH0P19wfGB7xN94DDByaXrDfCB9QTdj5J84FHBHQcY8dBkQC5l+MAEQ3LpD4C2BPa1nEDKpT8gx9AIgi9tEMmPoQ0E3T8UHB/4IdEHDhecXLrRAB/YSND9I5IP/Ehwx4ENBFs0G5BLGT7QYkgu/THQlsC+li2kXPpjcgydS/ClTSL5MbSJoPsxwfGBx4g+MEBwculmA3xgM0H34yQfeFxwxwFGPLQakEsZPlA0JJf+BGhLYF/LIimX/oQcQ+cRfGmLSH4MbSHofkJwfOAJog8MFJxcutUAH9hK0P0kyQeeFNxxgBEPNxmQSxk+MNGQXPoU0JbAvpYTSbn0KXIMnU/wpW0i+TG0jaD7p4LjAz8l+sARgpNLnzbAB54m6H6G5APPCO44wIiHmw3IpQwfuMWQXPos0JbAvpa3kHLps+QYuoDgS8+J5MfQcwTdzwuODzxP9IFBgpNLtxvgA9sJun9G8oGfCe44wIiHSQbkUoYP3GpILv050JbAvpa3knLpz8kxdCHBl3aI5MfQDoLuXwiOD/yC6AODBSeX7jTAB3YSdP+S5AO/FNxxgBEPkw3IpQwfuM2QXPoroC2BfS1vI+XSX5Fj6CKCL70gkh9DLxB0/1pwfODXRB8YIji5dJcBPrCLoPs3JB/4jeCOA4x4uN2AXLqLoHuKIbn0t0BbAvtaTiHl0t96YqgK7Ev2GHoi2DdPIPjm7wTWN4f67SizsQ5b90mlHGMh2ngn+zXHQLTxTmlvw8iINl5W1ScREW08KZR9HAnRxqsVZXwmAqKNlxNlfTA0oo1XJzQ+HRLRxqsX2hgJhWjjNYgKMRcC0cbLi4oxHBjRxitUxguMaOM1BsELiGjjDQuGFwjRfc90ILwAiO67NgPiVUR03zcWGK8CovvOlRB4WkR33/lQeBpEd+/dkHhlEd39B0PjlUF092CKgKdEdPehiISnQHTX4kbEa4forkeKjOdDdOdkx8ArQXTnpcXC8yC6v83HxNuL6P4+ERvPQXSf0QDwdiPaeBej8Jzr1EsE7vrUxvud2HeAeGarxZ5r6YwH+07Vd8S4NrxU7HmWUmKLlsi2kDbe8UB+I8H8Rqr4xWA4SsWvNS+j8hsF5jcazG+0ml9khmPU/Gpbs9H4jQHzGwvmN7Ycv4gMx5XjJ3PZKPzGgfmNB/MbX55fJIZN5fnJxmJ4fk1gfs1gfs06fhEYFjX8rP4thOVXBPObCOY3Uc8vNMNJen6NE/Lh+E0C85sM5je5Er+QDKdU4leoK4bhNwXMbyqY39TK/EIxnFaRn9W/dcH5TQPzuwPM744g/EIwnB6EX/2E+qD8poP5zQDzmxGMX2CGM4Pxayhkg/GbCeZ3N5jf3UH5BWQ4Kyg/WcgG4TcLzG82mN/s4PwCMZwTnJ+sz1fmNwfM7x4wv3vC8AvA8N4w/Ar1zZX43QvmNxfMb244fhUZzgvHr6U2r+c3D8xvPpjf/LD8KjBcEJZfIVer47cAzG8hmN/C8Py0DBeF55drzZfntwjMbzGY3+Io/DQMl0ThV6jLl+O3BMxvKZjf0mj8yjJcFo1fIV9Q81sG5rcczG95VH5lGK6Iys9qUfFbAea3EsxvZXR+SoarovNrbCi257cKzG81mN/qOPwUDNfE4Gf1b9bPbw2Y31owv7Xx+LVjuC4eP1lXW8pvHZjfejC/9XH5+RhuiMsv15r18tsA5rcRzG9jfH4lDDfF5yeLdfv4bQLz2wzmtxnBz8NwC4JffWOty28LmN9WML+tGH57GW7D8Mu17iEot4H5PQ3m9zSKn8PwORi/os1QPgfmtx3MbzuO326GO4D8LIZyB5jfTjC/nUh+FsMXQPy86/CQ/HaB+e1y+IHX9WSBmrNVYt/xovP5knBIuwtL7IY2X91LTp0oJzDGRC67Ey4V+MUhX+mIBVsxdY8k6F7aMQvVIiu3dY8i6P6qAbpHE3R/raMWJkZUbuseQ9C9zADdYwm6H+y4haiRlNu6xxF0LzdA93iC7oc6cuFxBOW27iaC7q8boLuZoHtFxy40D63c1l0k6P6GAbonEnSv7OiNBUIqt3VPIuj+pgG6JxN0f6vjN5IIpdzWPYWge5UBuqcSdH+743WHUm7rnkbQvdoA3XcQdD+8P3SHUG7rnk7Q/YgBumcQdK/ZP7oDK7d1zyTo/o4Buu8m6F67v3QHVG7rnkXQ/V0DdM8m6P7e/tMdSLmtew5B9zoDdN9D0P39/ak7gHJb970E3esN0D2XoPvR/au7onJb9zyC7h8YoHs+QfeG/a27gnJb9wKC7h8aoHshQffG/a9bq9zWvYig+0cG6F5M0P3jJOjWKLd1LyHo3mSA7qUE3Y8lQ3dZ5bbuZQTdmw3QvZyg+/Gk6C6j3Na9gqD7JwboXknQvSU5upXKbd2rCLqfMED3aoLurUnSrVBu615D0P2kAbrXEnQ/lSzd7ZTbutcRdG8zQPd6gu6fJk23T7mtewNB99MG6N5I0P1M8nSXKLd1byLoftYA3ZsJup9Lom6Pclv3FoLu5w3QvZWge3syde9VbutmvPT9ZwboZrz0/edJ1e0ot3UzXky8wwDdjBcT/yK5uncrt3UzXp650wDdlBeoJll3ds/LqRgvePuVAbp3EXS/ANbtHtPBPF8MjlVxs76X/FgxXhxQn8FhNWTaaYy8IX8eiFXIKGwfcaP7RiDWsIzSJyJtIH8qEOs0NVakjdlPB2KdkSkbQ6E3PD8TiDU8o4ntkBuJnwXEOluHFXKD7nOAWCMyFcbCEBtfnwvEOq8SVogNpc8HYl1QGSvwRs0XArEuCoIVcAPki4FYlwTDCrSx8KVArMuCYgW4BhgJxLo8OFbFjXCvAGKNCoNVYYPZK4FYo8NhaTduvQqIdXVYLM2GqGOAWNeExyq70ehYINa1UbDKbOB5HRBrXDQs5caY1wOxxkfEUm04eQMQ68boWO02cmwCYk2Ig+XbILEZiNUSD6tk48FWIFYxLpZnQ7+bgFgT42Pt3SjvZiDWLRCsPRvQTQJi3QrCsjd2mwzEug2A5T7PuR2INQX3DEsC9w2TwL24JHB/KwncM0oC92GSwL2NJHC/IAncg0cC97WRwL1iJHD/FQnc00QC9wmRwL03JHA/CwncI0IC912QwL0MJHB/AAlccy+B69glcG24BK63lsA1zBK4LlgC19pK4PpVCVwTKoHrLOUGIBZwPaAErrGTwHVrErgWTALXV0ngmiUJXAckgWtrJHC9igSuAZHAdRUSuFZBAuf/S+Ccegmcpy6Bc78lcD61BM5RlsB5vxI4l1YC56dK4JxPCZxHKYFzEyVwvp8EzqGTwHlpEjjXSwLnT0nknKRqC6PKKeWOoN9V6XdALyZ6/teLOKxsxsPzZZesu9n/yx7y7tHJJwY5masC14obw7wM5PU/OGfIem1q47aRbfoSEAtp09+HsGml7/La9PeOTaud4vdZIfBB+JLgBOEfmIT/QMB9BeggLN2veAwMws26jtYRzpYB8vZmv1edz9dc0m5E2Q1tvrrXROWRKxvvKBEa15leDY5VcVrPayK9DPEd8lXBGQFfFz7He13wL0NCiKl4GfI6kNf/Cs5liI3bRrbpa0AspE3/KDiXIX8UHX8ZghyYvHz/xCT8JwLun0WyL0Ns3X/2GBiEW7LQBh3AryS0f/5PYLNxRwUrkreX71+YhP9CwH1DJDtYbd1veAwMwqVwtYPUDq4qHy4y+ONi/RWo19Mt8JWFyNuPv/mx0pWF6cpCIFa6sjBdWZiuLExXFqYrC9OVhenKwnRlYbqyMF1ZaGOlKwvTlYXpysJIWOnKwnRlYbqyEISVriwMh5WuLAyHla4sDIeVriwMh5WuLAyHla4sDIeVriwMh5WuLAyHla4sDIeVriwMh5WuLAyHla4sDIeVriwMh5WuLAyHhV5Z2FGTCP+GwyqZRPh3JuG/E3D/IXAP91i6/+ExMAiXwtWe7PhXgX+lwJsCG2T2DOcq0f5A2yMD7q87VfwqLiQpf1xqYRzn76cYkwJtvOOB/EaC+Y1U8YvBcJSKX4zJi6PA/EaD+Y1W84vMcIyaX+RJlmPA/MaC+Y0txy8iw3Hl+EWcDDoOzG88mN/48vwiMWwqzy/SpNUmML9mML9mHb8IDIsaflEm1xbB/CaC+U3U8wvNcJKeX+hJwJPA/CaD+U2uxC8kwymV+IWcrDwFzG8qmN/UyvxCMZxWkV+4SdXTwPzuAPO7Iwi/EAynB+EXYvL3dDC/GWB+M4LxC8xwZjB+gSepzwTzuxvM7+6g/AIynBWUX8DJ9LPA/GaD+c0Ozi8QwznB+QWa9D8HzO8eML97wvALwPDeMPwCLE64F8xvLpjf3HD8KjKcF45fxUUU88D85oP5zQ/LrwLDBWH5VVjssQDMbyGY38Lw/LQMF4Xnp12UsgjMbzGY3+Io/DQMl0Thp1k8swTMbymY39Jo/MoyXBaNX9lFPsvA/JaD+S2Pyq8MwxVR+ZVZjLQCzG8lmN/K6PyUDFdF56dcNLUKzG81mN/qOPwUDNfE4Kda3LUGzG8tmN/aePzaMVwXj1+7RWjrwPzWg/mtj8vPx3BDXH6+xXIbwPw2gvltjM+vhOGm+PxKFvVtAvPbDOa3GcHPw3ALgp9n8eEWML+tYH5bMfz2MtyG4bd3keQ2ML+nwfyeRvFzGD4H47dnMedzYH7bwfy24/jtZrgDyM9edLoDzG8nmN9OJD978iOInzvP6wUwv11gfrscfuB5Ylmg5pLJmG/ZXNGT8ezJiG/ijSCRk/xsbu5+um95uLJsUUW0RVyO/wTaVbVbfTopMZ2UGOZIJyXG45dOSozHL52UGI9fOikxHr90UmI8fumkxHj80kmJ8filkxLj8UsnJZY50kmJ6aTEbDopscLXp5MS00mJ6aTEGPzSSYnx+KWTEuPxSyclxuO3HMwvnZSYTkoMwy+dlBiPXzopMR6/dFJiPH4bwfw2xueXTkqMyy+dlBiXXzopMS6/dFJiXH7ppMS4/NJJiSie0EmJVWLf8S/n899CMTkxG++Q9mS3tzxfhhIg8AaWNs9/CvykxLcTrtt2gLcJuv8fqNs7gdTGbXNw0bb4N8kWIsOxhf0f1xbucReYe8b/uqX0lddarPSV1+Gw0ldeh8NKX3mdvvLaj5W+8jrcJJH0ldfhJjWkr7wO9yN8+srrcD8ap6+8DvcjZ/rK63A/yqWvvA73I1L6yutwP3qkr7wO95A+feV1uGcw6Suvw2Glr7wOh5W+8jocVvrK63BY6Suvw2Glr7wOh5W+8jocVvrK63BY6Suvw2Glr7wOh5W+8jocVvrK63BY6Suvw2Glr7wOh5W+8jocVlJfeW1jZBwsFzPu8ybW/LK5VftVd8XfOVlzyT5D1p2Nd8jdmjP4TRiB/S2RNrQ3YawS6jdYi5A2qORTXkx0v/0Lh1Wy62lVxrNBJcPZkKTdiZVe0iE5V9xx4m0fvosbd2CYBx4Y3KM6ZJ+FmRAdV3OnTDIHGGRfeP3S1tsmSo+w/VPJ5sj+qfb0j8zlrNhoyctiSzFXn2+snSAbcg0NxbpivqFQ11Ksr2tqybfKuqZcbWNrPluUhdbWfH2uOd9QbGxpbih6B23ZksvVtTROaJb1tQ1NE7KFllxTtliXz9Vmm1py+ZaWXKGhoSmXa2koFAuNhdrapmKukK3P5xuzDbW5xlpW/1Q7/aPamdc90GNgBodVsjKkxiHa2ZQBnMWvhjBYd8lwHLBLhrc64m2fM6Bs0ZVki64aWyBW9TD8Yn7C72pYPnBfwu9qbLzdF25gXGB/S6QN3yl3NTXgscU9upl4V9ONfFfTjTAwfP6/8K6meyaZAwyyL7x+2d2wu5oDgHc19wHvalj9c4DnrqZcUkjy4ygmT1aCOdDEBHMgOcEcSEgwC0gJpgbMEzmA9cgk8ncYaLJaQBoMewRIVnFtelAGlxRKHpslKFmx+uegd9AjuIMdoj0zhDfHldvwJBvvkMg3nKk6C6W7iqg7Lsde5B/1s/EOaTtmL0Iy7k16FNib+Fi0J8kWfUi26EN8LMryiy8m/LEoywfuN+CxqK0bPZYC+1sibfhOeSx6MOmutS/zrrUXaUDsS7xrtTn3JQwMi0h3rejHor2Ad5r9MskcYJB94fXLfh3wWBTZP4cAH4veD7zTZPXPIfvjThM4BnqTWH+H6KGmDOAsfv0Jg/VhpMR1GPGuxrbFoQRbHE6yxeHEuxqWXyxO+F0NywceSPpdTYZzVwPsb4m04TvlrqY/6a5mgIl3NQPIdzUDCAPDl/8L72oGZpI5wCD7wuuXAw27qzkCeFfzAPCuhtU/R2Q6frIH8nEUkycrwQwyMcEMIieYQYQEs4SUYNCTPZAD2GAgFvKxGTJZLSENhoMz/MkeQzK4pFDy2CxByYrVP0OIT0Ds3/MZv+kNJT8Fi7dxZbH4poUxFH/3W/sm0IZHJvxJoq31SILvHAXWje7jVyyMPwP1/tXCOIrwJKYKGC+vCOzY5uYX7wWi9zrL/dvWMN3zb45xPhcvH/TIgBerrvU0iWM1bSdo2k7StI1xPp/43LbHHvx4U4u37VpN23jns9+LZx32ni3LzvW2NWnOa9G0TdRgTtKcd5umbaoGc5rmvDs1bTM0mDM1531Y0zZbgzlHc94nNW1zNZjzNOfdp2lbqMFcpDnvAU3bUg3mMs15D2naVmowV2nOe1jTtlaDuU5z3qOato0azE2a8x7XtG3VYG7TnPeMpm27BnOH5rxfatp2aTB/pznvZU3bKxrM1zXn/UnT9oYG8++a897StL2twXQnCavOq9a0dc2UxzxAc95BmrbeGsx+mvMO1bQN1GAO1px3pKbtWA3mcZrzTtS0ZTWYOc15DZq2YRrM0zXnDde0jdBgnq857yJN22UazCs0543WtF2jwbxOc954TdsEDWar5ryJmrZbNZi3a86bqml7vwbzLs15MzRtbRrMWU6b6prvo5q2xzRtj2vantS0PaVpe1bT9rym7Q+atlc1bW9o2v6maXtT0/ZPTVunqvJtNZq27pq2AzVtPTVtvTVth2vaBmraBmvahmrajtO0naBpy2raasu0uc913fugbs6nez/qPosa7n5HzPvSbh5cNH7Bus/tJkoPMP9cNweTaR8Xk4Cf7eLgnNO2D9+vxT56iNJ7ce85Xa3S23OOF0OIfc8uvee67Ux9hWxdnYtfTcC3Hv9ke7ga29rbz22rbiv9bm9bjafN5Wjbc6DPPgz/8tqH41+12T6ivE/ZOt/VATrtX996+L7b/Q7vd5N8RGZ83yd89ha+7+8uqDEvM77vc/n47eP2RS+r9BSlMezvKxdriHtyD8UJLvgBnvoubaUkdn966twAcQOmq/ff+9q6edqq2/Z9r310d/6/2vM9XiyXR43v37sPEg92Pjt7znHP76n4/s6+7y/hrajzGtOP1UlR5/77zlYZ7Pxt29VNeNVt+/BQzpMv7PsV37V9jSh1GuH7/hrfvz/R+f/uPr2uEw2PyLOYb5LFXFOxqb6ppaWuuam3D99rM9tOQ52/zb7AqWtIL3D0B+oCp4fn39nHCA9extd2ruK7zL7Qydb2UfD3XrAMcP7upPh3/hjfu+mwj6v3UGGokk830b7fhkfT3G6Sjl+nTpvbVuPTqtLtPb9GtNdd48P396lQfEenMueqcKs0Oiqd67/ALXchYEIuGuL8//7ORcc7f6e5SHvkyLmiljyGKnORajzV5SJ/zNnHCKdNlae8uch/w0O6qawn95OsdFM5ROw7vHatEeXzSI3v37r5zL6+7uWzWw1HV4Pbt51F+8Nt6+L57oyvratCV0aBpcq1riYb41gPrv/f+fl4Y6WLr03l27a2Qc7f/tztfg53PrPxDqnikVHwqHSvmvQ8dozz//s7j6liz9XRWZSPvUr27+/8neZH7ZHmR5Hmx2yA/Nhrn2lgMZr0MfIQ5//39xjp2sn97Cfw9sp6xrK+HPy9seo9+nn+7uvT6Y3H4SAOLp7rBzUKTlW+Nm8cePll8Pykn0snxXe5Rx/ns6+nzrXnfwAbQOVTObACAA==","debug_symbols":"7Z3dThtJE4bvhWMOut7q39zKp08rkrArJARRflZaRbn3tVnGgCF2iMf46Zk5iWLSrlS/bb9VNePHfD/7ePn+219/XN38efvl7N3/vp9d3364+Hp1e7N69P0s3P3oy6eLm/WjL18vPn89e+cWz88ubz6u/qb04/zsz6vry7N3WT/Ony/1XIe1XvLuxdZyuV9srerx4v+fnxknFXFScU4qkZNK4qSSOakUTiqVk0oDWRzJbkF+ayDDNZDjGshyDeS5BjJdA7mugWzXQL4rkO+K1OeCfFcg3xXIdwXyXYF8VyDfFch3BfJdB/mug3zXSRcY3tR3FSzcL1ZItp1LBOWSQLnkt82l1E0ubU9kW/3fw4trFXpPZCs2RLZaN4ut3u2yTGSXipuzVPbHu3y+OG7em7E9WtruBKlTEaTmIbKHdoAgbSKCeNtEjopb74MYJrLLpDZETrnuPnbLYVOk8qMN3ktiiyTbkmiOkpTkQ+TyKOdXO0n0Rb0D1IuzVK9tIlerB6iXFvUOUI/cC8fN+8tz2GriI7m93Zk4uQ3dmfjbtourGW7T5Wp7hEsBlIuBcnnbNiaaPzTedTsXB+USQbkkUC4ZlEsB5VJBuTROLjmAcjFQLiDfzSDfzSDfzSDfzSDfzSDfzSDfzSDfLSDfLSDfLSDfLSDfLSDfLSDfLSDfLSDfLSDfLSDfrSDfrSDfrSDfrSDfrSDfrSDfrSDfrSDfrSDfrSDfbSDfbSDfbSDfbSDfbSDfbSDfbSDfbSDfbSDfbSDftQAyXgsg57UAsl4LIO+1ADJfCyD3tQCyXwsg/7UAMmALJAc2kgMbyYGN5MBGcmAjObCRHNhIDmwkBzaSAxvJgUVyYJEcWCQHFsmBRXJgkRxYJAcWyYFFcmCRHNhJDuwkB3aSAzvJgZ3kwE5yYCc5sJMc2EkO7CQHjiQHjiQHjiQHjiQHjiQHjiQHjiQHjiQHjiQHjiQHTiQHTiQHJkFuRqLcjIS5GYlzMxLoZiTSzUiom5FYNyPBbkai3YyEuxmJdzMS8GYk4s1IyJuRmDcjQW9Got6MhL0ZiXszEvhmJPLNSOibkdg3I8FvRqLfjIS/GYl/MxIAZyQCzkgInJEYOCNBcEai4IyEwRmJgzMSCGckEs5IKJyRWDgjwXBGouGMhMMZiYczEhBnJCLOSEickZg4kZg4kZg4kZg4kZg4BZADi8TEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEicTEOYmJcxIT5yQmzklMnAeQAzuJiXMSE+ckJs5JTJyTmDgnMXFOYuKcxMQ5iYlzEhPnJCbOSUyck5g4JzFxTmLinMTEOYmJcxIT5yQmzklMnJOYOCcxcU5i4pzExDmJiXMSE+ckJs5JTJyTmDgnMXFOYuKcxMQ5iYlzEhPnJCbOSUyck5g4JzFxTmLinMTEOYmJcxIT5yQmzklMnJOYOCcxcU5i4pzExDmJiXMSE+ckJs5JTJyTmDgnMXFOYuKcxMQ5iYlzEhPnJCbOSUyck5g4JzFxTmLinMTEOYmJcxIT5yQmzklMnJOYOCcxcU5i4pzExDmJiXMSE+ckJs5JTJyTmDgnMXFOYuKcxMT5WzNxeQisFNKzZDIpmZcd2G34D1LZk0yOm7U5h92LLTTdLzYLcU/mVobIsvpwplb/y7xyM1cMQ+bK/jjz54tjLvdrY3u0tP23yQbeZM3DJj20Azb5E+APsUlv9cFX4vZr8Cd0YA+Zq9vMvdvMY7eZp24zz91mDq7MezIHV+Y9mYPL7c7MY+i1hsbQaw2NodcaGkOvNTSGXmtoDL3W0Bh6raEx9FpDY+i1hsbQbQ21bmuodVtDrdsaat3WUOu2hlq3NdS6raHWbQ21bmuodVtD1W0NVbc1VN3WUHVbQ9VtDVW3NVTd1lB1W0PVbQ1VtzXUu62h3m0N9W5rqHdbQ73bGurd1lDvtoZ6tzXUu62h3m0Njd3W0NhtDY3d1tDYbQ2N3dbQ2G0Njd3W0NhtDY3d1tDYbQ1N3dbQBK6hSW3IPOUnn2p/IXIOw+emLT/CAoZtggvumNsEV+dXbbOkAVKx8ojbePUn5mMCV/0TKQLuJl6nSEtD5Gr1EEXAXcqJFHnb7melw0YRPYl8l0wlJdNAyeTD2462WVvMxnzh7kTSYjZu5mMhaTELvMmRkLSYnbvJ3a1vjtzMR+wJc5rHNvNEtjlao5fLosiWInUqiozV6OW2KPJUkfK2PdXuBq8YKRmRkjm47ai2WVujnsWPR46fjhw/Hzl+OXL8g626lrKJX/d89UdOYegUc3J77AkvvYxz20xwpez2GvcwFC/farTvttlmsc0a5rFNm8c2NY9t+kS2GX3zJUir61fPthnnsc00j23mqWyzPGyz7bkKp9o232nWQtqzePeVycO/5mvyAo52gbROpcnrQeupdJodaN2m0u4eUeux7j+0qfTcPWg9lcb/eFrvvuXUJjNSnErAuAh4mICTGYNOJeAyYO0TcMS7um2Zxt5S7WUeG1Xt0W5ct2V4Qx5MCsukBz2YZSwc92BG+nxFCssMCT2YWc6m7UHrFm3P4p13DlKIi4D7rkSNdIU1hVmOsSfSepYT7+u0HukKawqznHdPpPUsp91Xab3zUlgKs5xKRxTQZjk9jingLKe8Vwk43uXBZLMc3U6m9jKPjar2aJeWDv9S+OVgjnMwy1AIPZhlghz3YMa65mfLuAk9mDnOph42DZGHGA7rnuY4m44poOY4m75OwNHqo+Y4xp5K6zkOsafSeo4j7Cu1HqtjOPzXrCxa/7LWUxk0U4qblPOeeykjQnZJUxkIjyfgaLdvNZUZrwetpzK29aD1VCa8I2o91q1yn8ow2IPWUxkGj6f17pvCPpUJ72QCTmVsO5mAcRFwz+IRb5T7Mo29pdrL6MYkXnyZ86AHswyF0INZJkgmihSXcRN6MLOcTUdkxOIsZ9PTcEtxlmPsibSOi9b7tB7rAmGc5bx7Iq1nOe2OSOjEWU6lYwo4y+lxTAFnOeWdilpKsxzdTqb2Mo8xiZe0zHnQg1mGQujBxOVgkNf80jJuQg9mjrPpmIhTmuNsOqqAc5xNT8TSpDmOsSfSOs9xiD2V1nMcYU/ELeU5TqWn0noGvz1w9eD956vr66u//ri+/XDx9er25sv6qWH9x8sEfrPh5Jr2CBCVNvqq+O49pRiGWz7pyUXgu9N4GWY/US4GykWgXByUSwTlkii5rB7Y3Tv7RXUsbH6hswXf8/mlEob0i2lrrHj5a5zGC58PD+9D81Ni2w5fRgivIfzTD2Wsw9fjhm+Hh69DcSmtbIV/2YfHC28Hh68aXv6Pfyn5fXiNEH5oL2rK2+H98PBlONr6XJw4Yvi29bZaPdAOa7AwPHH11/pr7xiLm07Mcv61t8Hu57TXP+cnL9jdz7HfeI5+4zn+G8+Jr3/Oyx+TriENnx2r4WlVWb8a/Oevhp3PXD36++Lz1cX768t1K7n+x283H4bOcvXw6z+fhn8Zes9Pn28/XH789vly3YU+NKBreVTPva7Pfn2O3s5jfKhi6x+pnLseXr13q3Tu5WEL6x9ZOddq1Y9Vfv8C","file_map":{"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        /*@safety: borrow is enforced to be boolean due to its type.\n            if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n            if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n        */\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            /*@safety: decomposition is properly checked below*/\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            unsafe {\n                //@safety: already unconstrained\n                field_less_than(b, a)\n            },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety: unsafe in unconstrained\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        unsafe {\n            //@safety: Take a hint of the comparison and verify it\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::runtime::is_unconstrained;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        unsafe {\n            //@safety : unconstrained context\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"use std::cmp::Ordering;\nuse std::field::bn254::decompose;\nuse std::ops::{Add, Mul, Sub};\nfn main(x: Field, y: pub Field) -> pub Ordering {\n    let new_x = Quantized::new(x);\n    let new_y = Quantized::new(y);\n    let zero = Quantized::zero();\n    let add0 = new_x + zero;\n    let sub = add0 - new_y;\n    let mul = new_x * sub;\n    Quantized::cmp(mul, new_y)\n}\n\npub struct Quantized {\n    // if value positive: x*scale\n    // if negative: (p-x)*scale, where p is the prime of native Field (in this case from barretenberg)\n    // the original value is max 60 bits, positive or negative,\n    // this leaves enough space for additions and additions of single multiplications\n    // 2^60-1 = 1152921504606846975\n    // -1152921504606846975 <= x <= 1152921504606846975\n    // -1152921504606846975/65536 <= value <= 1152921504606846975/65536\n    pub x: Field,\n}\npub unconstrained fn get_bytes(x: Field) -> [u8; 32] {\n    x.to_be_bytes()\n}\n\n/// Check if the integer value is possitive based on the Field value used to\n/// encode it.\npub fn is_positive(x: Field) -> bool {\n    let (_, higher_bytes) = decompose(x);\n    higher_bytes == 0\n}\n\n// check if there are bytes from 0-15, then it is negative\n// This assumes the values that are multiplied have max ~60-63 bits\npub fn is_negative(x: Field) -> bool {\n    let (_, higher_bytes) = decompose(x);\n    higher_bytes != 0\n}\nimpl Quantized {\n\n    pub fn zero() -> Self {\n        Quantized { x: 0 }\n    }\n\n    pub fn new(x: Field) -> Self {\n        Self { x: x }\n    }\n\n    fn add(self: Self, other: Self) -> Self {\n        Quantized { x: self.x + other.x } // if one is negative, this wraps around automatically\n    }\n\n    fn sub(self: Self, other: Self) -> Self {\n        Quantized { x: self.x - other.x }\n    }\n\n    fn mul(self: Self, other: Self) -> Self {\n        let mut temp: Field = self.x * other.x;\n        let mut bytes: [u8; 32] = [0; 32];\n        unsafe {\n            //@safety: get_bytes is safe\n            bytes = get_bytes(temp);\n        }\n\n        assert(Field::from_be_bytes::<32>(bytes) == temp);\n\n        let negative = is_negative(temp);\n\n        // To correctly scale down we temporary flip the sign\n        if negative {\n            temp = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - temp\n                + 1;\n            unsafe {\n                //@safety: get_bytes is safe\n                bytes = get_bytes(temp);\n            }\n\n            assert(Field::from_be_bytes::<32>(bytes) == temp);\n        }\n\n        // Chop off 2 bytes to scale down by 2^16 and truncate\n        let mut truncated: [u8; 32] = [0; 32];\n        for i in 0..30 {\n            // [0, 0, am, .., a2] (chop off a0 and a1)\n            truncated[i + 2] = bytes[i];\n        }\n\n        let mut new_x: Field = Field::from_be_bytes::<32>(truncated);\n        // Flip back sign if the output is negative\n        if negative {\n            new_x = 21888242871839275222246405745257275088548364400416034343698204186575808495616\n                - new_x\n                + 1;\n        }\n\n        Quantized { x: new_x }\n    }\n}\n\nimpl Add for Quantized {\n    fn add(self, other: Self) -> Self {\n        self.add(other)\n    }\n}\n\nimpl Sub for Quantized {\n    fn sub(self, other: Self) -> Self {\n        self.sub(other)\n    }\n}\n\nimpl Mul for Quantized {\n    fn mul(self, other: Self) -> Self {\n        self.mul(other)\n    }\n}\n\nimpl Ord for Quantized { // TODO is it cheaper to create a function that returns a bool directly?\n    fn cmp(self: Self, other: Self) -> Ordering {\n        if self.x == other.x {\n            Ordering::equal()\n        }\n\n        let self_positive = is_positive(self.x);\n        let other_positive = is_positive(other.x);\n\n        if (self_positive & !other_positive) {\n            Ordering::greater()\n        } else if self_positive == other_positive {\n            let self_smallest = self.x.lt(other.x);\n            if self_smallest {\n                Ordering::less()\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            Ordering::less()\n        }\n    }\n}\n","path":"co-snarks/co-noir/co-noir/examples/test_vectors/quantized/src/main.nr"}},"names":["main"],"brillig_names":["get_bytes","decompose_hint","lte_hint","field_less_than","directive_invert"]}
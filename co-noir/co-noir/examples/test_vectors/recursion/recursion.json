{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":12573438407499533940,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":3,"type":{"kind":"field"}},"visibility":"public"},{"name":"key_hash","type":{"kind":"field"},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":463,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"}}},"bytecode":"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","debug_symbols":"ldTLaoQwFAbgdzlrF7ka9VVKGaLGIRCiRC0U8d2bGbRIZ6D8y3P5/k0uG/WuXe83H4dxpuZjozB2dvFjzNVG7NmaJxsf1bzYtFAjalOQiz01SlZ7QYMPjppS7MXLKjdCHbu8YuZ3WbL9syD+Ll1zfggt1TU9A4ECiQKFAo2CEgUGBRUKahRwBov3Zy3Pm6RL9lcIWEhYKFhoWJSwMLCoYFGjQjBY/Pe+X4XARC7a5EPw99v128rtL5u8bYM7ymGN3WW6fE/n5PRTGjvXr8k9kp6zHP8D","file_map":{"30":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod bigint;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    unsafe {\n        //@safety: a print statement cannot be constrained\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"62":{"source":"global SIZE_OF_PROOF_IF_LOGN_IS_28: u32 = 463;\nglobal HONK_IDENTIFIER: u32 = 1;\nfn main(\n    verification_key: [Field; 128],\n    public_inputs: pub [Field; 3],\n    key_hash: Field,\n    proof: [Field; SIZE_OF_PROOF_IF_LOGN_IS_28],\n) -> pub u64 {\n    // verify sum so far was computed correctly\n    std::verify_proof_with_type(\n        verification_key,\n        proof,\n        public_inputs,\n        key_hash,\n        HONK_IDENTIFIER,\n    );\n    // Take output of previous proof and add another number to it.\n    public_inputs[2] as u64 + public_inputs[1] as u64\n}\n","path":"/home/fabsits/co-snarks/co-noir/co-noir/examples/test_vectors/recursion/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}
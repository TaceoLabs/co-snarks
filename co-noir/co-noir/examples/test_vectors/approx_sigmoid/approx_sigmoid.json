{"noir_version":"1.0.0-beta.1+03b58fa2dfcc8acc8cf5198b1b23b55676fbdb02","hash":17519681017905997142,"abi":{"parameters":[{"name":"x","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"}}},"bytecode":"H4sIAAAAAAAA/+VaW27TQBQdO2mdR5M+0rTpA1JKxQ8SmvEjGf/BBwtJFOefXbAA9gAr4QM+2AQLIQMe6dZOR1Q+t7KbK0XjZDIn955z7tiO7Il/cbd56fzY27xa+WjivbgffuFzWSXmakmxIjmL42weZipSCxmmS53IOFnOtNIq0ckq1FGU6VjP02U6l6mKo0ytkzRa53A+Kq9NUB58bh6kVD6QhxYorzBRGeWhxcxDuCkU6Ye24PFDW/D7oQ3kYQ+Uly7wsCea1Rf7oLxWi9Wa8mBx2wUOaBT306q1VOBYkePEYhUDgP03KBdBPnYsIZbAIB/pZx1RNleLkcRHYskClgqAeXWA4jbQlKGWT2fKbj72LCHWgF1RNmVPNMuUXWBePbC4XjVRS78R5Jqh9UA2NlKPPpC7bXogajU5oq8I+sAcD3B5sXn6gEGbQc3rNldUA4a6hzWv22g9ZKj7EFg3PR9SXFTO2Xpt0tbW+y0gxxvoFNjzagjU6KgB3jxi8OYxkzePHd6U1ULZcxuai5Oae8Dc8Z8w1D2qed1G6xFD3adM3j9l9D7XPjBugAfGDHWfMXngjNEDXP3wakc9cAuu2wb6XvgcyCVQa4Xkj/bQucBf39L/Fcx1BPr+GPkfw0TUux+NThMGbS4ETz/6DB5CYV0CdeHQ2mhyyaD1leDZOyiuDfR+fC2e/37M4SXjo2sGL71g8hLFbUpfvd5RD9wJnnMHeu94CeQSqLVC8kd7iNbLxel0xzid/genslrMAiAPU6DWN0yc3gj+p2q8GvNgH1jwRDk8Mh5u4efnl1/fv31erOgaizf+/eHi04+vH+ncvmNdx7Gu55ibODCvHOumjnW3jrk3Dsy3jnXvHHOhAzN2rJs9sM7qZjm999CFKD9dKKtFaPH7PPgyEOXokeN+Yc76s71lnffAe78wur7r6pXBljmLOcpHmq+t4w+AWn3bHiwAAA==","debug_symbols":"tdjLaoQwGAXgd8nahSb5c/FVShkcjUNAVLwUisy7VwdTbAqzCWcZc/wWwWOMG2vcfX3cfN8OMys/NtYNdbX4od9HGytel+ax6o/RvFTTwkohMub6hpWUPzPW+s6xUvFn9j+o5ZkUhl+jnxnjMFkkyZLMmZTKRrKEyZQkE/0mVbwaCibrRJmHpC4i2cBkmyQrmZ9JRfFqFDmOTmuhEeG5M3+jB81xtMDREkenNdEYFWhrYlrhaI2jDY5Oa6MVYQ+wUsW7S1obrQmvEGtlTBewonOOowWOljiacLTC0RpH47ZGbmG0yHF0gaM5jhY4WuJowtEKR+O+UwWujSKtjW9PMTmOLnA0x9HAEyPuyCgJRyscrXG0wdG4NhKujYRrI+HaSLg2EqqN++A++a7zj9v199l++auafHXv3Dls176+zC7fY5gJ94/TULtmndwhveZ2/gc=","file_map":{"62":{"source":"fn main(x: u64) -> pub u64 {\n    approx_sigmoid(x)\n}\n\nfn approx_sigmoid(x: u64) -> u64 {\n    // Follows https://github.com/data61/MP-SPDZ/blob/master/Compiler/ml.py#L110\n    // [-5, -2.5, 2.5, 5]\n    let cuts: [u64; 4] = [\n        327680, // -5/2^-16, -327680\n        163840, // -2.5/2^-16, -163840\n        163840, // 163840\n        327680, // 327680\n    ];\n\n    let temp = 1819 * x;\n    let outputs = [\n        6, // 0.0001, 0.0001 / 2^-16 = 6.5536\n        temp + 9502, //0.02776 and 0.145, 0.02776 / 2^-16 = 1819.27936, 0.145/2^-16 = 9502.72\n        (11141 * x) + 32768, //0.17 and 0.5, 0.17 / 2^-16 = 11141.12, 0.5/2^-16 = 32768\n        temp + 56031, //0.02776 and 0.85498, 0.85498/2^-16 = 56031.96928\n        65529, //0.9999 / 2^-16 = 65529.4464\n    ];\n\n    // Determine the correct interval index by checking against each cut\n    if x <= cuts[0] {\n        outputs[0]\n    } else if x <= cuts[1] {\n        outputs[1]\n    } else if x <= cuts[2] {\n        outputs[2]\n    } else if x <= cuts[3] {\n        outputs[3]\n    } else {\n        outputs[4]\n    }\n}\n","path":"co-snarks/co-noir/co-noir/examples/test_vectors/approx_sigmoid/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient"]}
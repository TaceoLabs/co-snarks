use circom_types::traits::CheckElement;
use clap::{Args, Parser, Subcommand, ValueEnum};
use co_circom::{
    Bls12_381, Bn254, CircomArkworksPairingBridge, CircomArkworksPrimeFieldBridge,
    CoCircomCompiler, CompilerConfig, Compression, Groth16, Groth16JsonVerificationKey,
    Groth16Proof, Groth16ZKey, Pairing, Plonk, PlonkJsonVerificationKey, PlonkProof, PlonkZKey,
    Rep3CoGroth16, Rep3CoPlonk, Rep3MpcNet, Rep3SharedInput, ShamirCoGroth16, ShamirCoPlonk,
    ShamirMpcNet, ShamirSharedWitness, SimplificationLevel, VMConfig, Witness, R1CS,
};
use co_circom_snarks::{CompressedRep3SharedWitness, VerificationError};
use color_eyre::eyre::{self, eyre, Context, ContextCompat};
use figment::{
    providers::{Env, Format, Serialized, Toml},
    Figment,
};
use mpc_net::config::NetworkConfigFile;
use num_traits::Zero;
use serde::{Deserialize, Serialize};
use std::{
    fs::File,
    io::{BufReader, BufWriter},
    path::PathBuf,
    process::ExitCode,
    sync::Arc,
    time::Instant,
};
use tracing::instrument;

/// An enum representing the ZK proof system to use.
#[derive(Debug, Clone, ValueEnum, Serialize, Deserialize)]
#[clap(rename_all = "lower")]
pub enum ProofSystem {
    /// The Groth16 proof system.
    Groth16,
    /// The Plonk proof system.
    Plonk,
}

impl std::fmt::Display for ProofSystem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ProofSystem::Groth16 => write!(f, "Plonk"),
            ProofSystem::Plonk => write!(f, "Groth16"),
        }
    }
}

/// An enum representing the curve to use.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Curve {
    /// The BN254 curve (called BN128 in circom).
    BN254,
    /// The BLS12_381 curve.
    BLS12_381,
}

impl ValueEnum for Curve {
    fn value_variants<'a>() -> &'a [Self] {
        &[Curve::BN254, Curve::BLS12_381]
    }

    fn to_possible_value(&self) -> Option<clap::builder::PossibleValue> {
        match self {
            Curve::BN254 => Some(clap::builder::PossibleValue::new("BN254")),
            Curve::BLS12_381 => Some(clap::builder::PossibleValue::new("BLS12-381")),
        }
    }
}

impl std::fmt::Display for Curve {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Curve::BN254 => write!(f, "BN254"),
            Curve::BLS12_381 => write!(f, "BLS12-381"),
        }
    }
}

/// An enum representing the MPC protocol to use.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, ValueEnum)]
#[clap(rename_all = "UPPER")]
pub enum MPCProtocol {
    /// A protocol based on the Replicated Secret Sharing Scheme for 3 parties.
    /// For more information see <https://eprint.iacr.org/2018/403.pdf>.
    REP3,
    /// A protocol based on Shamir Secret Sharing Scheme for n parties.
    /// For more information see <https://iacr.org/archive/crypto2007/46220565/46220565.pdf>.
    SHAMIR,
}

impl std::fmt::Display for MPCProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MPCProtocol::REP3 => write!(f, "REP3"),
            MPCProtocol::SHAMIR => write!(f, "SHAMIR"),
        }
    }
}

/// Cli arguments for `split_witness`
#[derive(Debug, Default, Serialize, Args)]
pub struct SplitWitnessCli {
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the input witness file generated by Circom
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub witness: Option<PathBuf>,
    /// The path to the r1cs file, generated by Circom compiler
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub r1cs: Option<PathBuf>,
    /// The MPC protocol to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The path to the (existing) output directory
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out_dir: Option<PathBuf>,
    /// The threshold of tolerated colluding parties
    #[arg(short, long, default_value_t = 1)]
    pub threshold: usize,
    /// The number of parties
    #[arg(short, long, default_value_t = 3)]
    pub num_parties: usize,
}

/// Config for `split_witness`
#[derive(Debug, Deserialize)]
pub struct SplitWitnessConfig {
    /// The path to the input witness file generated by Circom
    pub witness: PathBuf,
    /// The path to the r1cs file, generated by Circom compiler
    pub r1cs: PathBuf,
    /// The MPC protocol to be used
    pub protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The path to the (existing) output directory
    pub out_dir: PathBuf,
    /// The threshold of tolerated colluding parties
    pub threshold: usize,
    /// The number of parties
    pub num_parties: usize,
}

/// Cli arguments for `split_input`
#[derive(Debug, Default, Clone, Serialize, Args)]
pub struct SplitInputCli {
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the input JSON file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub input: Option<PathBuf>,
    /// The path to the circuit file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub circuit: Option<String>,
    /// The MPC protocol to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The path to the (existing) output directory
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out_dir: Option<PathBuf>,
}

/// Config for `split_input`
#[derive(Debug, Clone, Deserialize)]
pub struct SplitInputConfig {
    /// The path to the input JSON file
    pub input: PathBuf,
    /// The path to the circuit file
    pub circuit: String,
    /// The MPC protocol to be used
    pub protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The path to the (existing) output directory
    pub out_dir: PathBuf,
    /// MPC compiler config
    #[serde(default)]
    pub compiler: CompilerConfig,
}

/// Cli arguments for `merge_input_shares`
#[derive(Debug, Default, Serialize, Args)]
pub struct MergeInputSharesCli {
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the input JSON file
    #[arg(long)]
    pub inputs: Vec<PathBuf>,
    /// The MPC protocol to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The output file where the merged input share is written to
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out: Option<PathBuf>,
}

/// Config for `merge_input_shares`
#[derive(Debug, Deserialize)]
pub struct MergeInputSharesConfig {
    /// The path to the input JSON file
    pub inputs: Vec<PathBuf>,
    /// The MPC protocol to be used
    pub protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The output file where the merged input share is written to
    pub out: PathBuf,
}

/// Cli arguments for `generate_witness`
#[derive(Debug, Default, Serialize, Args)]
pub struct GenerateWitnessCli {
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the input share file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub input: Option<PathBuf>,
    /// The path to the circuit file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub circuit: Option<String>,
    /// The MPC protocol to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The output file where the final witness share is written to
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out: Option<PathBuf>,
    /// The simplification level passed to the circom compiler (0-2)
    #[arg(short = 'O', default_value_t = 1, value_parser = clap::value_parser!(u8).range(0..3))]
    pub simplification_level: u8,
}

/// Config for `generate_witness`
#[derive(Debug, Deserialize)]
pub struct GenerateWitnessConfig {
    /// The path to the input share file
    pub input: PathBuf,
    /// The path to the circuit file
    pub circuit: String,
    /// The MPC protocol to be used
    pub protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The output file where the final witness share is written to
    pub out: PathBuf,
    /// MPC compiler config
    #[serde(default)]
    pub compiler: CompilerConfig,
    /// MPC VM config
    #[serde(default)]
    pub vm: VMConfig,
    /// Network config
    pub network: NetworkConfigFile,
}

/// Cli arguments for `transalte_witness`
#[derive(Debug, Serialize, Args)]
pub struct TranslateWitnessCli {
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the witness share file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub witness: Option<PathBuf>,
    /// The MPC protocol that was used for the witness generation
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub src_protocol: Option<MPCProtocol>,
    /// The MPC protocol to be used for the proof generation
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub target_protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The output file where the final witness share is written to
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out: Option<PathBuf>,
}

/// Config for `transalte_witness`
#[derive(Debug, Deserialize)]
pub struct TranslateWitnessConfig {
    /// The path to the witness share file
    pub witness: PathBuf,
    /// The MPC protocol that was used for the witness generation
    pub src_protocol: MPCProtocol,
    /// The MPC protocol to be used for the proof generation
    pub target_protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The output file where the final witness share is written to
    pub out: PathBuf,
    /// Network config
    pub network: NetworkConfigFile,
}

/// Cli arguments for `generate_proof`
#[derive(Debug, Serialize, Args)]
pub struct GenerateProofCli {
    /// The proof system to be used
    #[arg(value_enum)]
    pub proof_system: ProofSystem,
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the witness share file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub witness: Option<PathBuf>,
    /// The path to the proving key (.zkey) file, generated by snarkjs setup phase
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub zkey: Option<PathBuf>,
    /// Perform checks on the zkey elements (can take a long time)
    #[arg(long)]
    pub check_zkey: bool,
    /// The MPC protocol to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub protocol: Option<MPCProtocol>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The output file where the final proof is written to. If not passed, this party will not write the proof to a file.
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub out: Option<PathBuf>,
    /// The output JSON file where the public inputs are written to. If not passed, this party will not write the public inputs to a file.
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub public_input: Option<PathBuf>,
    /// The threshold of tolerated colluding parties
    #[arg(short, long, default_value_t = 1)]
    pub threshold: usize,
}

/// Config for `generate_proof`
#[derive(Debug, Deserialize)]
pub struct GenerateProofConfig {
    /// The proof system to be used
    pub proof_system: ProofSystem,
    /// The path to the witness share file
    pub witness: PathBuf,
    /// The path to the proving key (.zkey) file, generated by snarkjs setup phase
    pub zkey: PathBuf,
    /// Perform checks on the zkey elements (can take a long time)
    pub check_zkey: bool,
    /// The MPC protocol to be used
    pub protocol: MPCProtocol,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The output file where the final proof is written to. If not passed, this party will not write the proof to a file.
    pub out: Option<PathBuf>,
    /// The output JSON file where the public inputs are written to. If not passed, this party will not write the public inputs to a file.
    pub public_input: Option<PathBuf>,
    /// The threshold of tolerated colluding parties
    pub threshold: usize,
    /// Network config
    pub network: NetworkConfigFile,
}

/// Cli arguments for `verify`
#[derive(Debug, Serialize, Args)]
pub struct VerifyCli {
    /// The proof system to be used
    #[arg(value_enum)]
    pub proof_system: ProofSystem,
    /// The path to the config file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub config: Option<PathBuf>,
    /// The path to the proof file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub proof: Option<PathBuf>,
    /// The pairing friendly curve to be used
    #[arg(long, value_enum)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub curve: Option<Curve>,
    /// The path to the verification key file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub vk: Option<PathBuf>,
    /// The path to the public input JSON file
    #[arg(long)]
    #[serde(skip_serializing_if = "::std::option::Option::is_none")]
    pub public_input: Option<PathBuf>,
}

/// Config for `verify`
#[derive(Debug, Deserialize)]
pub struct VerifyConfig {
    /// The proof system to be used
    pub proof_system: ProofSystem,
    /// The path to the proof file
    pub proof: PathBuf,
    /// The pairing friendly curve to be used
    pub curve: Curve,
    /// The path to the verification key file
    pub vk: PathBuf,
    /// The path to the public input JSON file
    pub public_input: PathBuf,
}

/// Prefix for config env variables
pub const CONFIG_ENV_PREFIX: &str = "COCIRCOM_";

/// Error type for config parsing and merging
#[derive(thiserror::Error, Debug)]
#[error(transparent)]
pub struct ConfigError(#[from] figment::error::Error);

macro_rules! impl_config {
    ($cli: ty, $config: ty) => {
        impl $config {
            /// Parse config from file, env, cli
            pub fn parse(cli: $cli) -> Result<Self, ConfigError> {
                if let Some(path) = &cli.config {
                    Ok(Figment::new()
                        .merge(Toml::file(path))
                        .merge(Env::prefixed(CONFIG_ENV_PREFIX))
                        .merge(Serialized::defaults(cli))
                        .extract()?)
                } else {
                    Ok(Figment::new()
                        .merge(Env::prefixed(CONFIG_ENV_PREFIX))
                        .merge(Serialized::defaults(cli))
                        .extract()?)
                }
            }
        }
    };
}

impl_config!(SplitInputCli, SplitInputConfig);
impl_config!(SplitWitnessCli, SplitWitnessConfig);
impl_config!(MergeInputSharesCli, MergeInputSharesConfig);
impl_config!(TranslateWitnessCli, TranslateWitnessConfig);
impl_config!(GenerateProofCli, GenerateProofConfig);
impl_config!(VerifyCli, VerifyConfig);

// manual one since this is a bit more complex
impl GenerateWitnessConfig {
    /// Parse config from file, env, cli
    pub fn parse(cli: GenerateWitnessCli) -> Result<Self, ConfigError> {
        let simplification_level = cli.simplification_level;
        let mut config: GenerateWitnessConfig = if let Some(path) = &cli.config {
            Figment::new()
                .merge(Toml::file(path))
                .merge(Env::prefixed(CONFIG_ENV_PREFIX))
                .merge(Serialized::defaults(cli))
                .extract()?
        } else {
            Figment::new()
                .merge(Env::prefixed(CONFIG_ENV_PREFIX))
                .merge(Serialized::defaults(cli))
                .extract()?
        };
        match simplification_level {
            0 => config.compiler.simplification = SimplificationLevel::O0,
            1 => config.compiler.simplification = SimplificationLevel::O1,
            2 => config.compiler.simplification = SimplificationLevel::O2(usize::MAX),
            _ => {}
        }
        Ok(config)
    }
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Splits an existing witness file generated by circom into secret shares for use in MPC
    SplitWitness(SplitWitnessCli),
    /// Splits a JSON input file into secret shares for use in MPC
    SplitInput(SplitInputCli),
    /// Merge multiple shared inputs received from multiple parties into a single one
    MergeInputShares(MergeInputSharesCli),
    /// Evaluates the extended witness generation for the specified circuit and input share in MPC
    GenerateWitness(GenerateWitnessCli),
    /// Translates the witness generated with one MPC protocol to a witness for a different one
    TranslateWitness(TranslateWitnessCli),
    /// Evaluates the prover algorithm for the specified circuit and witness share in MPC
    GenerateProof(GenerateProofCli),
    /// Verification of a circom proof.
    Verify(VerifyCli),
}

fn install_tracing() {
    use tracing_subscriber::prelude::*;
    use tracing_subscriber::{
        fmt::{self, format::FmtSpan},
        EnvFilter,
    };

    let fmt_layer = fmt::layer()
        .with_target(false)
        .with_line_number(false)
        .with_span_events(FmtSpan::CLOSE | FmtSpan::ENTER);
    let filter_layer = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .init();
}

fn main() -> color_eyre::Result<ExitCode> {
    install_tracing();
    rustls::crypto::aws_lc_rs::default_provider()
        .install_default()
        .map_err(|_| eyre!("Could not install default rustls crypto provider"))?;
    let args = Cli::parse();

    match args.command {
        Commands::SplitWitness(cli) => {
            let config = SplitWitnessConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_split_witness::<Bn254>(config),
                Curve::BLS12_381 => run_split_witness::<Bls12_381>(config),
            }
        }
        Commands::SplitInput(cli) => {
            let config = SplitInputConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_split_input::<Bn254>(config),
                Curve::BLS12_381 => run_split_input::<Bls12_381>(config),
            }
        }
        Commands::MergeInputShares(cli) => {
            let config = MergeInputSharesConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_merge_input_shares::<Bn254>(config),
                Curve::BLS12_381 => run_merge_input_shares::<Bls12_381>(config),
            }
        }
        Commands::GenerateWitness(cli) => {
            let config = GenerateWitnessConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_generate_witness::<Bn254>(config),
                Curve::BLS12_381 => run_generate_witness::<Bls12_381>(config),
            }
        }
        Commands::TranslateWitness(cli) => {
            let config = TranslateWitnessConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_translate_witness::<Bn254>(config),
                Curve::BLS12_381 => run_translate_witness::<Bls12_381>(config),
            }
        }
        Commands::GenerateProof(cli) => {
            let config = GenerateProofConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_generate_proof::<Bn254>(config),
                Curve::BLS12_381 => run_generate_proof::<Bls12_381>(config),
            }
        }
        Commands::Verify(cli) => {
            let config = VerifyConfig::parse(cli).context("while parsing config")?;
            match config.curve {
                Curve::BN254 => run_verify::<Bn254>(config),
                Curve::BLS12_381 => run_verify::<Bls12_381>(config),
            }
        }
    }
}

#[instrument(level = "debug", skip(config))]
fn run_split_witness<P: Pairing + CircomArkworksPairingBridge>(
    config: SplitWitnessConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let witness_path = config.witness;
    let r1cs = config.r1cs;
    let protocol = config.protocol;
    let out_dir = config.out_dir;
    let t = config.threshold;
    let n = config.num_parties;

    // read the circom witness file
    let witness_file =
        BufReader::new(File::open(&witness_path).context("while opening witness file")?);
    let witness = Witness::<P::ScalarField>::from_reader(witness_file)
        .context("while parsing witness file")?;

    // read the circom r1cs file
    let r1cs_file = BufReader::new(File::open(&r1cs).context("while opening r1cs file")?);
    let r1cs = R1CS::<P>::from_reader(r1cs_file).context("while parsing r1cs file")?;

    tracing::info!("Starting split witness...");
    match protocol {
        MPCProtocol::REP3 => {
            if t != 1 {
                return Err(eyre!("REP3 only allows the threshold to be 1"));
            }
            if n != 3 {
                return Err(eyre!("REP3 only allows the number of parties to be 3"));
            }
            // create witness shares
            let start = Instant::now();
            let shares =
                co_circom::split_witness_rep3(&r1cs, witness, Compression::SeededHalfShares);
            let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
            tracing::info!("Split witness took {duration_ms} ms");

            // write out the shares to the output directory
            let base_name = witness_path
                .file_name()
                .context("we have a file name")?
                .to_str()
                .context("witness file name is not valid UTF-8")?;
            for (i, share) in shares.iter().enumerate() {
                let path = out_dir.join(format!("{}.{}.shared", base_name, i));
                let out_file =
                    BufWriter::new(File::create(&path).context("while creating output file")?);
                bincode::serialize_into(out_file, share)
                    .context("while serializing witness share")?;
                tracing::info!("Wrote witness share {} to file {}", i, path.display());
            }
        }
        MPCProtocol::SHAMIR => {
            // create witness shares
            let start = Instant::now();
            let shares = co_circom::split_witness_shamir(&r1cs, witness, t, n);
            let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
            tracing::info!("Split witness took {duration_ms} ms");

            // write out the shares to the output directory
            let base_name = witness_path
                .file_name()
                .context("we have a file name")?
                .to_str()
                .context("witness file name is not valid UTF-8")?;
            for (i, share) in shares.iter().enumerate() {
                let path = out_dir.join(format!("{}.{}.shared", base_name, i));
                let out_file =
                    BufWriter::new(File::create(&path).context("while creating output file")?);
                bincode::serialize_into(out_file, share)
                    .context("while serializing witness share")?;
                tracing::info!("Wrote witness share {} to file {}", i, path.display());
            }
        }
    }
    tracing::info!("Split witness into shares successfully");
    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_split_input<P: Pairing + CircomArkworksPairingBridge>(
    config: SplitInputConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let input_path = config.input;
    let circuit = config.circuit;
    let protocol = config.protocol;
    let out_dir = config.out_dir;

    if protocol != MPCProtocol::REP3 {
        return Err(eyre!(
            "Only REP3 protocol is supported for splitting inputs"
        ));
    }
    let circuit_path = PathBuf::from(&circuit);

    //get the public inputs if any from parser
    let public_inputs = CoCircomCompiler::<P>::get_public_inputs(circuit_path, config.compiler)
        .context("while reading public inputs from circuit")?;

    // read the input file
    let input = BufReader::new(File::open(&input_path).context("while opening input file")?);
    let input = serde_json::from_reader(input)?;

    tracing::info!("Starting split input...");
    let start = Instant::now();
    let shares = co_circom::split_input::<P>(input, &public_inputs)?;
    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
    tracing::info!("Split input took {duration_ms} ms");

    // write out the shares to the output directory
    let base_name = input_path
        .file_name()
        .context("we have a file name")?
        .to_str()
        .context("input file name is not valid UTF-8")?;
    for (i, share) in shares.iter().enumerate() {
        let path = out_dir.join(format!("{}.{}.shared", base_name, i));
        let out_file = BufWriter::new(File::create(&path).context("while creating output file")?);
        bincode::serialize_into(out_file, share).context("while serializing witness share")?;
        tracing::info!("Wrote input share {} to file {}", i, path.display());
    }
    tracing::info!("Split input into shares successfully");
    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_merge_input_shares<P: Pairing + CircomArkworksPairingBridge>(
    config: MergeInputSharesConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let inputs = config.inputs;
    let protocol = config.protocol;
    let out = config.out;

    if protocol != MPCProtocol::REP3 {
        return Err(eyre!(
            "Only REP3 protocol is supported for merging input shares"
        ));
    }

    if inputs.len() < 2 {
        return Err(eyre!("Need at least two input shares to merge"));
    }

    let input_shares = inputs
        .iter()
        .map(|input| {
            let input_share_file =
                BufReader::new(File::open(input).context("while opening input share file")?);
            let input_share: Rep3SharedInput<P::ScalarField> =
                bincode::deserialize_from(input_share_file)
                    .context("trying to parse input share file")?;
            color_eyre::Result::<_>::Ok(input_share)
        })
        .collect::<Result<Vec<_>, _>>()?;

    tracing::info!("Starting input shares merging...");
    let start = Instant::now();
    let merged = co_circom::merge_input_shares(input_shares)?;
    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
    tracing::info!("Merge input shares took {duration_ms} ms");

    let out_file = BufWriter::new(File::create(&out).context("while creating output file")?);
    bincode::serialize_into(out_file, &merged).context("while serializing witness share")?;
    tracing::info!("Wrote merged input share to file {}", out.display());

    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_generate_witness<P: Pairing + CircomArkworksPairingBridge>(
    config: GenerateWitnessConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let input = config.input;
    let circuit = config.circuit;
    let protocol = config.protocol;
    let out = config.out;

    if protocol != MPCProtocol::REP3 {
        return Err(eyre!(
            "Only REP3 protocol is supported for witness generation"
        ));
    }

    // connect to network
    let network_config = config
        .network
        .to_owned()
        .try_into()
        .context("while converting network config")?;
    let mpc_net = Rep3MpcNet::new(network_config).context("while connecting to network")?;

    // parse input shares
    let input_share_file =
        BufReader::new(File::open(&input).context("while opening input share file")?);
    let input_share: Rep3SharedInput<P::ScalarField> =
        bincode::deserialize_from(input_share_file).context("trying to parse input share file")?;

    // parse circuit file & put through our compiler
    let circuit = CoCircomCompiler::<P>::parse(circuit, config.compiler)
        .context("while parsing circuit file")?;

    // Extend the witness
    tracing::info!("Starting witness generation...");
    let start = Instant::now();
    let (result_witness_share, mpc_net) =
        co_circom::generate_witness_rep3::<P>(circuit, input_share, mpc_net, config.vm)?;
    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
    tracing::info!("Generate witness took {duration_ms} ms");
    // network is shutdown in drop, which can take seom time with quinn
    drop(mpc_net);

    // write result to output file
    let out_file = BufWriter::new(std::fs::File::create(&out)?);
    bincode::serialize_into(
        out_file,
        &CompressedRep3SharedWitness::from(result_witness_share),
    )?;
    tracing::info!("Witness successfully written to {}", out.display());
    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_translate_witness<P: Pairing + CircomArkworksPairingBridge>(
    config: TranslateWitnessConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let witness = config.witness;
    let src_protocol = config.src_protocol;
    let target_protocol = config.target_protocol;
    let out = config.out;

    if src_protocol != MPCProtocol::REP3 || target_protocol != MPCProtocol::SHAMIR {
        return Err(eyre!("Only REP3 to SHAMIR translation is supported"));
    }

    // parse witness shares
    let witness_file =
        BufReader::new(File::open(witness).context("trying to open witness share file")?);
    let witness_share: CompressedRep3SharedWitness<P::ScalarField> =
        bincode::deserialize_from(witness_file)?;

    // connect to network
    let network_config = config
        .network
        .to_owned()
        .try_into()
        .context("while converting network config")?;
    let net = Rep3MpcNet::new(network_config).context("while connecting to network")?;

    // Translate witness to shamir shares
    tracing::info!("Starting witness translation...");
    let start = Instant::now();
    let (shamir_witness_share, mpc_net) = co_circom::translate_witness::<P>(witness_share, net)?;
    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
    tracing::info!("Translate witness took {duration_ms} ms");
    // network is shutdown in drop, which can take seom time with quinn
    drop(mpc_net);

    // write result to output file
    let out_file = BufWriter::new(std::fs::File::create(&out)?);
    bincode::serialize_into(out_file, &shamir_witness_share)?;
    tracing::info!("Witness successfully written to {}", out.display());
    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_generate_proof<P: Pairing + CircomArkworksPairingBridge>(
    config: GenerateProofConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let proof_system = config.proof_system;
    let witness = config.witness;
    let zkey = config.zkey;
    let protocol = config.protocol;
    let out = config.out;
    let public_input_filename = config.public_input;
    let t = config.threshold;
    let check = if config.check_zkey {
        CheckElement::Yes
    } else {
        CheckElement::No
    };

    // parse witness shares
    let witness_file =
        BufReader::new(File::open(witness).context("trying to open witness share file")?);

    // parse Circom zkey file
    let zkey_file = File::open(zkey)?;

    let network_config = config
        .network
        .to_owned()
        .try_into()
        .context("while converting network config")?;

    tracing::info!("Starting proof generation...");
    let public_input = match proof_system {
        ProofSystem::Groth16 => {
            let zkey = Groth16ZKey::<P>::from_reader(zkey_file, check).context("reading zkey")?;
            let (matrices, pkey) = zkey.into();

            let (proof, public_input) = match protocol {
                MPCProtocol::REP3 => {
                    if t != 1 {
                        return Err(eyre!("REP3 only allows the threshold to be 1"));
                    }

                    let mut mpc_net = Rep3MpcNet::new(network_config)?;
                    let witness_share: CompressedRep3SharedWitness<P::ScalarField> =
                        bincode::deserialize_from(witness_file)?;
                    let witness_share = witness_share.uncompress(&mut mpc_net)?;
                    let public_input = witness_share.public_inputs.clone();

                    let start = Instant::now();
                    let (proof, mpc_net) =
                        Rep3CoGroth16::prove(mpc_net, &pkey, &matrices, witness_share)?;
                    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
                    tracing::info!("Generate proof took {duration_ms} ms");
                    // network is shutdown in drop, which can take seom time with quinn
                    drop(mpc_net);

                    (proof, public_input)
                }
                MPCProtocol::SHAMIR => {
                    let mpc_net = ShamirMpcNet::new(network_config)?;
                    let witness_share: ShamirSharedWitness<P::ScalarField> =
                        bincode::deserialize_from(witness_file)?;
                    let public_input = witness_share.public_inputs.clone();

                    let start = Instant::now();
                    let (proof, mpc_net) =
                        ShamirCoGroth16::prove(mpc_net, t, &pkey, &matrices, witness_share)?;
                    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
                    tracing::info!("Generate proof took {duration_ms} ms");
                    // network is shutdown in drop, which can take seom time with quinn
                    drop(mpc_net);

                    (proof, public_input)
                }
            };

            // write result to output file
            if let Some(out) = out {
                // convert proof to Groth16Proof for serialization
                let proof = Groth16Proof::from(proof);

                let out_file = BufWriter::new(
                    std::fs::File::create(&out).context("while creating output file")?,
                );

                serde_json::to_writer(out_file, &proof)
                    .context("while serializing proof to JSON file")?;
                tracing::info!("Wrote proof to file {}", out.display());
            }
            public_input
        }
        ProofSystem::Plonk => {
            let zkey = Arc::new(
                PlonkZKey::<P>::from_reader(zkey_file, check).context("while parsing zkey")?,
            );

            let (proof, public_input) = match protocol {
                MPCProtocol::REP3 => {
                    if t != 1 {
                        return Err(eyre!("REP3 only allows the threshold to be 1"));
                    }

                    let mut mpc_net = Rep3MpcNet::new(network_config)?;
                    let witness_share: CompressedRep3SharedWitness<P::ScalarField> =
                        bincode::deserialize_from(witness_file)?;
                    let witness_share = witness_share.uncompress(&mut mpc_net)?;
                    let public_input = witness_share.public_inputs.clone();

                    let start = Instant::now();
                    let (proof, mpc_net) = Rep3CoPlonk::prove(mpc_net, zkey, witness_share)?;
                    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
                    tracing::info!("Generate proof took {duration_ms} ms");
                    // network is shutdown in drop, which can take seom time with quinn
                    drop(mpc_net);

                    (proof, public_input)
                }
                MPCProtocol::SHAMIR => {
                    let mpc_net = ShamirMpcNet::new(network_config)?;
                    let witness_share: ShamirSharedWitness<P::ScalarField> =
                        bincode::deserialize_from(witness_file)?;
                    let public_input = witness_share.public_inputs.clone();

                    let start = Instant::now();
                    let (proof, mpc_net) = ShamirCoPlonk::prove(mpc_net, t, zkey, witness_share)?;
                    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
                    tracing::info!("Generate proof took {duration_ms} ms");
                    // network is shutdown in drop, which can take seom time with quinn
                    drop(mpc_net);

                    (proof, public_input)
                }
            };

            // write result to output file
            if let Some(out) = out {
                let out_file = BufWriter::new(
                    std::fs::File::create(&out).context("while creating output file")?,
                );

                serde_json::to_writer(out_file, &proof)
                    .context("while serializing proof to JSON file")?;
                tracing::info!("Wrote proof to file {}", out.display());
            }
            public_input
        }
    };

    // write public input to output file
    if let Some(public_input_filename) = public_input_filename {
        let public_input_as_strings = public_input
            .iter()
            .skip(1) // we skip the constant 1 at position 0
            .map(|f| {
                if f.is_zero() {
                    "0".to_string()
                } else {
                    f.to_string()
                }
            })
            .collect::<Vec<String>>();
        let public_input_file = BufWriter::new(
            std::fs::File::create(&public_input_filename)
                .context("while creating public input file")?,
        );
        serde_json::to_writer(public_input_file, &public_input_as_strings)
            .context("while writing out public inputs to JSON file")?;
        tracing::info!(
            "Wrote public inputs to file {}",
            public_input_filename.display()
        );
    }
    tracing::info!("Proof generation finished successfully");
    Ok(ExitCode::SUCCESS)
}

#[instrument(level = "debug", skip(config))]
fn run_verify<P: Pairing + CircomArkworksPairingBridge>(
    config: VerifyConfig,
) -> color_eyre::Result<ExitCode>
where
    P::ScalarField: CircomArkworksPrimeFieldBridge,
    P::BaseField: CircomArkworksPrimeFieldBridge,
{
    let proofsystem = config.proof_system;
    let proof = config.proof;
    let vk = config.vk;
    let public_input = config.public_input;

    // parse circom proof file
    let proof_file = BufReader::new(File::open(&proof).context("while opening proof file")?);

    // parse circom verification key file
    let vk_file = BufReader::new(File::open(&vk).context("while opening verification key file")?);

    // parse public inputs
    let public_inputs_file =
        BufReader::new(File::open(&public_input).context("while opening public inputs file")?);
    let public_inputs_as_strings: Vec<String> = serde_json::from_reader(public_inputs_file)
        .context(
            "while parsing public inputs, expect them to be array of stringified field elements",
        )?;
    // skip 1 atm
    let public_inputs = public_inputs_as_strings
        .into_iter()
        .map(|s| {
            s.parse::<P::ScalarField>()
                .map_err(|_| eyre!("could not parse as field element: {}", s))
        })
        .collect::<Result<Vec<P::ScalarField>, _>>()
        .context("while converting public input strings to field elements")?;

    // verify proof
    tracing::info!("Starting proof verification...");
    let start = Instant::now();
    let res = match proofsystem {
        ProofSystem::Groth16 => {
            let proof: Groth16Proof<P> = serde_json::from_reader(proof_file)
                .context("while deserializing proof from file")?;

            let vk: Groth16JsonVerificationKey<P> = serde_json::from_reader(vk_file)
                .context("while deserializing verification key from file")?;

            // convert circom vk and proof types to arkworks types
            let vk = vk.into();
            let proof = proof.into();

            Groth16::<P>::verify(&vk, &proof, &public_inputs)
        }
        ProofSystem::Plonk => {
            let proof: PlonkProof<P> = serde_json::from_reader(proof_file)
                .context("while deserializing proof from file")?;

            let vk: PlonkJsonVerificationKey<P> = serde_json::from_reader(vk_file)
                .context("while deserializing verification key from file")?;

            Plonk::<P>::verify(&vk, &proof, &public_inputs)
        }
    };
    let duration_ms = start.elapsed().as_micros() as f64 / 1000.;
    tracing::info!("Verify took {} ms", duration_ms);

    match res {
        Ok(_) => {
            tracing::info!("Proof verified successfully");
            Ok(ExitCode::SUCCESS)
        }
        Err(VerificationError::InvalidProof) => {
            tracing::error!("Proof verification failed");
            Ok(ExitCode::FAILURE)
        }
        Err(VerificationError::Malformed(err)) => eyre::bail!(err),
    }
}

use clap::Parser;
use color_eyre::eyre::{eyre, Context, Ok};
use std::io::Write;
use std::path::Path;
use std::process::Stdio;
use std::sync::mpsc::channel;
use std::time::Duration;
use std::{
    fs::File, io::BufWriter, path::PathBuf, process::Command, process::ExitCode, thread,
    time::Instant,
};

use co_circom::file_utils::{check_dir_exists, check_file_exists};

fn install_tracing() {
    use tracing_subscriber::prelude::*;
    use tracing_subscriber::{fmt, EnvFilter};

    let fmt_layer = fmt::layer().with_target(true).with_line_number(true);
    let filter_layer = EnvFilter::try_from_default_env()
        .or_else(|_| EnvFilter::try_new("info"))
        .unwrap();

    tracing_subscriber::registry()
        .with(filter_layer)
        .with(fmt_layer)
        .init();
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
/// Generates and verifies a proof for a given circuit using snarkjs and co-circom. Measures prover & verifier time and also measures witness generation time when run with --gen-wtns. Generates zkey from the circom file when run with --gen-zkey.
struct Cli {
    /// Input: The path to the proving key (.zkey) file, generated by the snarkjs setup phase
    #[arg(long, short)]
    zkey: PathBuf,
    /// Input (if --gen-wtns is set): The path to the input file (e.g. input.json)
    #[arg(long, short, required_if_eq("gen_wtns", "true"))]
    input: Option<PathBuf>,
    /// Input (if --gen-wtns is set): The path to the circom file (e.g. program.circom)
    #[arg(long, short, required_if_eq("gen_wtns", "true"))]
    circom: Option<PathBuf>,
    /// Input (optional if --gen-wtns is set): The path to circom library files (can be passed multiple times)
    #[arg(long, short)]
    link_library: Option<Vec<String>>,
    /// Input (if --gen-wtns is NOT set) The path to the witness file
    #[arg(long, short, required_unless_present = "gen_wtns")]
    witness: Option<PathBuf>,
    /// Input (if --gen-wtns is NOT set) The path to the r1cs file, generated by circom compiler
    #[arg(long, short, required_unless_present = "gen_wtns")]
    r1cs: Option<PathBuf>,
    /// Benchmarks witness generation in addition to proof generation and verification
    #[arg(long, default_value = "false")]
    gen_wtns: bool,
    /// Generates the zkey file and stores it in the path specified by --zkey in case that file does not exist yet. Use --pot-power to specify the power of tau to use.
    #[arg(long, default_value = "false", requires("gen_wtns"))]
    gen_zkey: bool,
    /// Like --gen-zkey, but overwrites the zkey file if it already exists.
    #[arg(long, default_value = "false", requires("gen_wtns"))]
    gen_zkey_force: bool,
    /// The power to use for the powers of tau ceremony (see <https://docs.circom.io/getting-started/proving-circuits/#powers-of-tau>)
    #[arg(long, default_value = "10")]
    pot_power: u16,
    /// MPC protocol for co-circom
    #[arg(long, default_value = "REP3")]
    protocol: String,
    /// MPC curve for co-circom
    #[arg(long, default_value = "BN254")]
    curve: String,
    /// Proof system
    #[arg(long, default_value = "groth16")]
    proof_system: String,
    /// The path to the co_circom binary
    #[arg(long, default_value = "co_circom")]
    co_circom_bin: String,
    /// The path to the snarkjs binary
    #[arg(long, default_value = "snarkjs")]
    snarkjs_bin: String,
    /// The path to the circom binary
    #[arg(long, default_value = "circom")]
    circom_bin: String,
    /// The path to the node binary
    #[arg(long, default_value = "node")]
    node_bin: String,
    /// The path to the data directory containing the certificates and keys for the parties
    #[arg(long, default_value = "collaborative-circom/examples/data")]
    data: PathBuf,
    /// The TCP port of party 1
    #[arg(long, default_value = "10000")]
    p1_port: u16,
    /// The TCP port of party 2
    #[arg(long, default_value = "10001")]
    p2_port: u16,
    /// The TCP port of party 3
    #[arg(long, default_value = "10002")]
    p3_port: u16,
    /// Intermediate output: The path to the verification key file
    #[arg(long, default_value = "tmp_verification_key.json")]
    vkey: PathBuf,
    /// Intermediate output: The path to the public input file for the snarkjs execution
    #[arg(long, default_value = "tmp_public_input_snarkjs.json")]
    pub_inp_sjs: PathBuf,
    /// Intermediate output: The path to the proof file for the snarkjs execution
    #[arg(long, default_value = "tmp_proof_snarkjs.json")]
    proof_sjs: PathBuf,
    /// Intermediate output: The path to the public input file 1 for the co-circom execution
    #[arg(long, default_value = "tmp_public_input_co_circom_0.json")]
    pub_inp_coc_1: PathBuf,
    /// Intermediate output: The path to the public input file 2 for the co-circom execution
    #[arg(long, default_value = "tmp_public_input_co_circom_1.json")]
    pub_inp_coc_2: PathBuf,
    /// Intermediate output: The path to the public input file 3 for the co-circom execution
    #[arg(long, default_value = "tmp_public_input_co_circom_2.json")]
    pub_inp_coc_3: PathBuf,
    /// Intermediate output: The path to the proof file 1 for the co-circom execution
    #[arg(long, default_value = "tmp_proof_co_circom_0.json")]
    proof_coc_1: PathBuf,
    /// Intermediate output: The path to the proof file 2 for the co-circom execution
    #[arg(long, default_value = "tmp_proof_co_circom_1.json")]
    proof_coc_2: PathBuf,
    /// Intermediate output: The path to the proof file 3 for the co-circom execution
    #[arg(long, default_value = "tmp_proof_co_circom_2.json")]
    proof_coc_3: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 1 for the co-circom execution
    #[arg(long, default_value = "tmp_party0.toml")]
    p1_toml: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 2 for the co-circom execution
    #[arg(long, default_value = "tmp_party1.toml")]
    p2_toml: PathBuf,
    /// Intermediate output: The path to the party configuration toml file 3 for the co-circom execution
    #[arg(long, default_value = "tmp_party2.toml")]
    p3_toml: PathBuf,
    /// Intermediate output: Generate witness: The path to the generated witness file from circom (and for co-circom wtns files that expand to gen_wtns_file.party_id.shared)
    #[arg(long, default_value = "tmp_circom_generated.wtns")]
    gen_wtns_file: PathBuf,
    /// Intermediate output: Generate zkey: The path to the "pot12_0000.ptau" file (see <https://docs.circom.io/getting-started/proving-circuits/#powers-of-tau>)
    #[arg(long, default_value = "tmp_pot_0000.ptau")]
    pot_0000: PathBuf,
    /// Intermediate output: Generate zkey: The path to the "pot12_0001.ptau" file (see <https://docs.circom.io/getting-started/proving-circuits/#powers-of-tau>)
    #[arg(long, default_value = "tmp_pot_0001.ptau")]
    pot_0001: PathBuf,
    /// Intermediate output: Generate zkey: The path to the "pot12_final.ptau" file (see <https://docs.circom.io/getting-started/proving-circuits/#phase-2>)
    #[arg(long, default_value = "tmp_pot_final.ptau")]
    pot_final: PathBuf,
    /// Intermediate output: Generate zkey: The path to the "multiplier2_0000.zkey" file (see <https://docs.circom.io/getting-started/proving-circuits/#phase-2>)
    #[arg(long, default_value = "tmp_circ_0000.zkey")]
    circ_0000: PathBuf,
    /// Intermediate output: Requirement for generating zkey: The path to the generated r1cs file
    #[arg(long, default_value = "tmp_generated_for_zkey_gen.r1cs")]
    r1cs_gen: PathBuf,
    /// Keep all intermediate output files
    #[arg(long, default_value = "false")]
    keep_artifacts: bool,
    /// Keep public input files (containing the computed outputs of the circuit) specified by --pub-inp-sjs, --pub-inp-coc-1, --pub-inp-coc-2, and --pub-inp-coc-3
    #[arg(long, default_value = "false")]
    keep_pub_inp: bool,
    /// Keep proof files specified by --proof-sjs, --proof-coc-1, --proof-coc-2, and --proof-coc-3
    #[arg(long, default_value = "false")]
    keep_proof: bool,
    /// Keep the verification key file specified by --vkey
    #[arg(long, default_value = "false")]
    keep_vkey: bool,
    /// Keep the generated witness file (circom) and the generated witness share files (co-circom) specified by --gen-wtns-file
    #[arg(long, default_value = "false")]
    keep_wtns: bool,
    /// Keep the generated input share files. Only applicable when --input is provided
    #[arg(long, default_value = "false")]
    keep_inp_shr: bool,
}

// filenames for certificates and keys that must be present inside the data directory
static PARTY_1_CERT_FILENAME: &str = "cert0.der";
static PARTY_2_CERT_FILENAME: &str = "cert1.der";
static PARTY_3_CERT_FILENAME: &str = "cert2.der";
static PARTY_1_KEY_FILENAME: &str = "key0.der";
static PARTY_2_KEY_FILENAME: &str = "key1.der";
static PARTY_3_KEY_FILENAME: &str = "key2.der";

#[derive(Debug, Clone)]
struct Config {
    do_gen_witness: bool,
    zkey: PathBuf,
    input: Option<PathBuf>,
    circom: Option<PathBuf>,
    circom_path: Option<PathBuf>,
    witness: Option<PathBuf>,
    witness_path: Option<PathBuf>,
    r1cs: Option<PathBuf>,
    data: PathBuf,
    co_circom_bin: String,
    snarkjs_bin: String,
    circom_bin: String,
    node_bin: String,
    p1_port: u16,
    p2_port: u16,
    p3_port: u16,
    keep_artifacts: bool,
    keep_pub_inp: bool,
    keep_proof: bool,
    keep_vkey: bool,
    keep_wtns: bool,
    keep_inp_shr: bool,
    protocol: String,
    curve: String,
    proof_system: String,
    vkey: PathBuf,
    pub_inp_sjs: PathBuf,
    proof_sjs: PathBuf,
    p1_cert: PathBuf,
    p2_cert: PathBuf,
    p3_cert: PathBuf,
    p1_key: PathBuf,
    p2_key: PathBuf,
    p3_key: PathBuf,
    wtns_shr_1: PathBuf,
    wtns_shr_2: PathBuf,
    wtns_shr_3: PathBuf,
    proof_coc_1: PathBuf,
    proof_coc_2: PathBuf,
    proof_coc_3: PathBuf,
    pub_inp_coc_1: PathBuf,
    pub_inp_coc_2: PathBuf,
    pub_inp_coc_3: PathBuf,
    p1_toml: PathBuf,
    p2_toml: PathBuf,
    p3_toml: PathBuf,
    gen_wtns_file: PathBuf,
    gen_zkey: bool,
    gen_zkey_force: bool,
    generate_witness_js: Option<PathBuf>,
    witness_calculator_js: Option<PathBuf>,
    generate_witness_js_folder: Option<PathBuf>,
    wasm_generated: Option<PathBuf>,
    link_library: Option<Vec<String>>,
    gen_inp_shr_1: Option<PathBuf>,
    gen_inp_shr_2: Option<PathBuf>,
    gen_inp_shr_3: Option<PathBuf>,
    pot_0000: PathBuf,
    pot_0001: PathBuf,
    pot_final: PathBuf,
    circ_0000: PathBuf,
    r1cs_gen: PathBuf,
    r1cs_gen_path: PathBuf,
    pot_power: u16,
}

impl From<Cli> for Config {
    fn from(cli: Cli) -> Self {
        // this whole function should be a dedicated function that returns a Result instead of panicking
        let p1_cert = cli.data.join(PARTY_1_CERT_FILENAME);
        let p2_cert = cli.data.join(PARTY_2_CERT_FILENAME);
        let p3_cert = cli.data.join(PARTY_3_CERT_FILENAME);
        let p1_key = cli.data.join(PARTY_1_KEY_FILENAME);
        let p2_key = cli.data.join(PARTY_2_KEY_FILENAME);
        let p3_key = cli.data.join(PARTY_3_KEY_FILENAME);
        let witness_path = {
            if let Some(witness) = &cli.witness {
                let tmp = witness.parent().expect("witness file has no parent");
                if tmp
                    .to_str()
                    .expect("witness file path is not valid utf-8")
                    .is_empty()
                {
                    Some(PathBuf::from("."))
                } else {
                    Some(PathBuf::from(tmp))
                }
            } else {
                None
            }
        };

        let witness_name = cli.witness.as_ref().map(|witness| {
            witness
                .file_name()
                .expect("we have a file name")
                .to_str()
                .expect("witness file name is not valid UTF-8")
        });

        let r1cs_gen_path = {
            let tmp = &cli.r1cs_gen.parent().expect("r1cs_gen file has no parent");
            if tmp
                .to_str()
                .expect("r1cs_gen file path is not valid utf-8")
                .is_empty()
            {
                PathBuf::from(".")
            } else {
                PathBuf::from(tmp)
            }
        };

        let circom_path = {
            if let Some(circom) = &cli.circom {
                let tmp = circom.parent().expect("circom file has no parent");
                if tmp
                    .to_str()
                    .expect("circom file path is not valid utf-8")
                    .is_empty()
                {
                    Some(PathBuf::from("."))
                } else {
                    Some(PathBuf::from(tmp))
                }
            } else {
                None
            }
        };

        let circom_name = cli.circom.as_ref().map(|circom| {
            let res = circom
                .file_name()
                .expect("we have a file name")
                .to_str()
                .expect("circom file name is not valid UTF-8");
            let split_pos = res
                .char_indices()
                .nth_back(6)
                .expect("checked in check_args")
                .0;
            &res[..split_pos]
        });

        let generate_witness_js = circom_path.as_ref().map(|circom_path| {
            circom_path.join(Path::new(&format!(
                "{}_js/generate_witness.js",
                &circom_name.expect("circom name must exist when circom_path exists")
            )))
        });

        let witness_calculator_js = circom_path.as_ref().map(|circom_path| {
            circom_path.join(Path::new(&format!(
                "{}_js/witness_calculator.js",
                &circom_name.expect("circom name must exist when circom_path exists")
            )))
        });

        let generate_witness_js_folder = circom_path.as_ref().map(|circom_path| {
            circom_path.join(Path::new(&format!(
                "{}_js",
                &circom_name.expect("circom name must exist when circom_path exists")
            )))
        });

        let wasm_generated = circom_name.as_ref().map(|circom_name| {
            circom_path
                .as_ref()
                .expect("circom path must exist when circom_name exists")
                .join(Path::new(&format!(
                    "{}_js/{}.wasm",
                    circom_name, circom_name
                )))
        });

        let tmp_wtns_path = {
            if let Some(witness_path) = &witness_path {
                witness_path.clone()
            } else {
                let tmp = cli
                    .gen_wtns_file
                    .parent()
                    .expect("witness file has no parent");
                if tmp
                    .to_str()
                    .expect("witness file path is not valid utf-8")
                    .is_empty()
                {
                    PathBuf::from(".")
                } else {
                    PathBuf::from(tmp)
                }
            }
        };
        let tmp_wtns_name = {
            if let Some(witness_name) = &witness_name {
                witness_name
            } else {
                cli.gen_wtns_file
                    .file_name()
                    .expect("we have a file name")
                    .to_str()
                    .expect("witness file name is not valid UTF-8")
            }
        };
        let wtns_shr_1 = tmp_wtns_path.join(Path::new(&format!("{}.{}.shared", tmp_wtns_name, 0)));
        let wtns_shr_2 = tmp_wtns_path.join(Path::new(&format!("{}.{}.shared", tmp_wtns_name, 1)));
        let wtns_shr_3 = tmp_wtns_path.join(Path::new(&format!("{}.{}.shared", tmp_wtns_name, 2)));

        let (gen_inp_shr_1, gen_inp_shr_2, gen_inp_shr_3) = {
            if let Some(input) = &cli.input {
                let path = {
                    let tmp = input.parent().expect("input file has no parent");
                    if tmp
                        .to_str()
                        .expect("input file path is not valid utf-8")
                        .is_empty()
                    {
                        PathBuf::from(".")
                    } else {
                        PathBuf::from(tmp)
                    }
                };
                let name = input
                    .file_name()
                    .expect("we have a file name")
                    .to_str()
                    .expect("input file name is not valid UTF-8");
                let gen_inp_shr_1 = path.join(Path::new(&format!("{}.{}.shared", name, 0)));
                let gen_inp_shr_2 = path.join(Path::new(&format!("{}.{}.shared", name, 1)));
                let gen_inp_shr_3 = path.join(Path::new(&format!("{}.{}.shared", name, 2)));
                (
                    Some(gen_inp_shr_1),
                    Some(gen_inp_shr_2),
                    Some(gen_inp_shr_3),
                )
            } else {
                (None, None, None)
            }
        };

        Config {
            do_gen_witness: cli.gen_wtns,
            zkey: cli.zkey,
            input: cli.input,
            circom: cli.circom,
            circom_path,
            witness: cli.witness,
            witness_path,
            r1cs: cli.r1cs,
            data: cli.data,
            co_circom_bin: cli.co_circom_bin,
            snarkjs_bin: cli.snarkjs_bin,
            circom_bin: cli.circom_bin,
            node_bin: cli.node_bin,
            p1_port: cli.p1_port,
            p2_port: cli.p2_port,
            p3_port: cli.p3_port,
            keep_artifacts: cli.keep_artifacts,
            keep_pub_inp: cli.keep_pub_inp,
            keep_proof: cli.keep_proof,
            keep_vkey: cli.keep_vkey,
            keep_wtns: cli.keep_wtns,
            keep_inp_shr: cli.keep_inp_shr,
            protocol: cli.protocol,
            curve: cli.curve,
            proof_system: cli.proof_system,
            vkey: cli.vkey,
            pub_inp_sjs: cli.pub_inp_sjs,
            proof_sjs: cli.proof_sjs,
            p1_cert,
            p2_cert,
            p3_cert,
            p1_key,
            p2_key,
            p3_key,
            wtns_shr_1,
            wtns_shr_2,
            wtns_shr_3,
            proof_coc_1: cli.proof_coc_1,
            proof_coc_2: cli.proof_coc_2,
            proof_coc_3: cli.proof_coc_3,
            pub_inp_coc_1: cli.pub_inp_coc_1,
            pub_inp_coc_2: cli.pub_inp_coc_2,
            pub_inp_coc_3: cli.pub_inp_coc_3,
            p1_toml: cli.p1_toml,
            p2_toml: cli.p2_toml,
            p3_toml: cli.p3_toml,
            gen_wtns_file: cli.gen_wtns_file,
            gen_zkey: cli.gen_zkey || cli.gen_zkey_force,
            gen_zkey_force: cli.gen_zkey_force,
            generate_witness_js,
            witness_calculator_js,
            generate_witness_js_folder,
            wasm_generated,
            link_library: cli.link_library,
            gen_inp_shr_1,
            gen_inp_shr_2,
            gen_inp_shr_3,
            pot_0000: cli.pot_0000,
            pot_0001: cli.pot_0001,
            pot_final: cli.pot_final,
            circ_0000: cli.circ_0000,
            r1cs_gen: cli.r1cs_gen,
            r1cs_gen_path,
            pot_power: cli.pot_power,
        }
    }
}

struct BenchResult {
    gen_wtns: Option<Duration>,
    prove: Duration,
    verify: Duration,
}

impl std::fmt::Display for BenchResult {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let witness = {
            if let Some(gen_wtns) = self.gen_wtns {
                format!("Witness Generation Time: {:?}, ", gen_wtns)
            } else {
                String::new()
            }
        };
        write!(
            f,
            "{}Prover Time: {:?}, Verifier Time: {:?}",
            witness, self.prove, self.verify
        )
    }
}

fn bench_circom_snarkjs(conf: &Config) -> color_eyre::Result<BenchResult> {
    let mut wtns_gen_time = None;
    if conf.do_gen_witness {
        tracing::trace!("Starting circom wasm generation ..");
        let out_circom = Command::new(&conf.circom_bin)
            .arg(conf.circom.as_ref().expect("gen_witness is true").as_path())
            .arg("--wasm")
            .arg("-o")
            .arg(
                conf.circom_path
                    .as_ref()
                    .expect("gen_witness is true")
                    .as_path(),
            )
            .args(link_library_to_args(conf, "-l")?)
            .output()
            .context("during executing circom")?;
        if !out_circom.status.success() {
            tracing::error!(
                "Failed to generate wasm using circom: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_circom.stdout)?,
                std::str::from_utf8(&out_circom.stderr)?
            );
            return Err(eyre!("Failed to generate wasm using circom"));
        }

        tracing::trace!("Starting witness generation using node generate_witness.js ..");
        let now = Instant::now();
        let out_node = Command::new(&conf.node_bin)
            .arg(
                conf.generate_witness_js
                    .as_ref()
                    .expect("gen_witness is true")
                    .as_path(),
            )
            .arg(
                conf.wasm_generated
                    .as_ref()
                    .expect("gen_witness is true")
                    .as_path(),
            )
            .arg(conf.input.as_ref().expect("gen_witness is true").as_path())
            .arg(conf.gen_wtns_file.as_path())
            .output()
            .context("during executing node generate_witness.js")?;
        wtns_gen_time = Some(now.elapsed());
        if !out_node.status.success() {
            tracing::error!(
            "Failed to generate witness using node generate_witness.js: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_node.stdout)?,
            std::str::from_utf8(&out_node.stderr)?
        );
            return Err(eyre!(
                "Failed to generate witness using node generate_witness.js"
            ));
        }
    }
    let wtns_gen_time = wtns_gen_time;

    let witness = {
        if conf.do_gen_witness {
            conf.gen_wtns_file.clone()
        } else {
            conf.witness
                .as_ref()
                .expect("gen_witness is false")
                .to_owned()
        }
    };

    tracing::trace!("Starting snarkjs prover ..");
    let now = Instant::now();
    let out_prove = Command::new(&conf.snarkjs_bin)
        .arg(&conf.proof_system)
        .arg("prove")
        .arg(conf.zkey.as_path())
        .arg(witness.as_path())
        .arg(conf.proof_sjs.as_path())
        .arg(conf.pub_inp_sjs.as_path())
        .output()
        .context("during executing \"snarkjs groth16 prove\"")?;
    let prover_time = now.elapsed();
    if !out_prove.status.success() {
        tracing::error!(
            "Failed to create proof using snarkjs: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_prove.stdout)?,
            std::str::from_utf8(&out_prove.stderr)?
        );
        return Err(eyre!("Failed to create proof using snarkjs"));
    }

    tracing::trace!("Starting snarkjs verifier ..");
    let now = Instant::now();
    let out_prove = Command::new(&conf.snarkjs_bin)
        .arg(&conf.proof_system)
        .arg("verify")
        .arg(conf.vkey.as_path())
        .arg(conf.pub_inp_sjs.as_path())
        .arg(conf.proof_sjs.as_path())
        .output()
        .context("during executing \"snarkjs groth16 verify\"")?;
    let verifier_time = now.elapsed();
    if !out_prove.status.success() {
        tracing::error!(
            "Failed to verify proof using snarkjs: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_prove.stdout)?,
            std::str::from_utf8(&out_prove.stderr)?
        );
        return Err(eyre!("Failed to verify proof using snarkjs"));
    }
    Ok(BenchResult {
        gen_wtns: wtns_gen_time,
        prove: prover_time,
        verify: verifier_time,
    })
}

macro_rules! party_config {
    ($id: expr, $port: expr, $key: expr, $conf: expr) => {
        format!(
            r#"[network]
my_id = {}
bind_addr = "0.0.0.0:{}"
key_path = "{}"
[[network.parties]]
id = 0
dns_name = "localhost:{}"
cert_path = "{}"
[[network.parties]]
id = 1
dns_name = "localhost:{}"
cert_path = "{}"
[[network.parties]]
id = 2
dns_name = "localhost:{}"
cert_path = "{}"
"#,
            $id,
            $port,
            $key.to_str().unwrap(),
            $conf.p1_port,
            $conf.p1_cert.to_str().unwrap(),
            $conf.p2_port,
            $conf.p2_cert.to_str().unwrap(),
            $conf.p3_port,
            $conf.p3_cert.to_str().unwrap(),
        )
    };
}

fn create_party_toml_files(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Creating party TOML files ..");

    let party1_toml = party_config!(0, conf.p1_port, conf.p1_key, conf);
    let party2_toml = party_config!(1, conf.p2_port, conf.p2_key, conf);
    let party3_toml = party_config!(2, conf.p3_port, conf.p3_key, conf);

    let mut out_file =
        BufWriter::new(File::create(&conf.p1_toml).context("while creating output file")?);
    out_file
        .write_all(party1_toml.as_bytes())
        .context("trying to write to file")?;
    let mut out_file =
        BufWriter::new(File::create(&conf.p2_toml).context("while creating output file")?);
    out_file
        .write_all(party2_toml.as_bytes())
        .context("trying to write to file")?;
    let mut out_file =
        BufWriter::new(File::create(&conf.p3_toml).context("while creating output file")?);
    out_file
        .write_all(party3_toml.as_bytes())
        .context("trying to write to file")?;
    Ok(())
}

fn bench_co_circom_prover_one_party(
    conf: &Config,
    wtns_shr: &Path,
    config_toml: &Path,
    proof_coc: &Path,
    pub_inp_coc: &Path,
) -> color_eyre::Result<std::sync::mpsc::Receiver<std::time::Duration>> {
    let (tx, rx) = channel();
    let tmp_conf = conf.clone();
    let wtns_shr = wtns_shr.to_owned();
    let config_toml = config_toml.to_owned();
    let proof_coc = proof_coc.to_owned();
    let pub_inp_coc = pub_inp_coc.to_owned();
    thread::spawn(move || {
        let conf = tmp_conf;
        let now = Instant::now();
        let out_co_circom_prove = Command::new(&conf.co_circom_bin)
            .arg("generate-proof")
            .arg(&conf.proof_system)
            .arg("--witness")
            .arg(wtns_shr)
            .arg("--zkey")
            .arg(conf.zkey.as_path())
            .arg("--curve")
            .arg(&conf.curve)
            .arg("--protocol")
            .arg(&conf.protocol)
            .arg("--config")
            .arg(config_toml)
            .arg("--out")
            .arg(proof_coc)
            .arg("--public-input")
            .arg(pub_inp_coc)
            .output()
            .context("during executing \"co-circom generate-proof\"")?;
        let prover_time = now.elapsed();
        if !out_co_circom_prove.status.success() {
            tracing::error!(
                "Failed to generate proof: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_co_circom_prove.stdout)?,
                std::str::from_utf8(&out_co_circom_prove.stderr)?
            );
            return Err(eyre!("Failed to generate proof"));
        }
        tx.send(prover_time).unwrap();
        Ok(())
    });
    Ok(rx)
}

fn bench_co_circom_prover(conf: &Config) -> color_eyre::Result<Duration> {
    tracing::trace!("Starting co-circom party 1 proof generation ..");
    let rx_1 = bench_co_circom_prover_one_party(
        conf,
        &conf.wtns_shr_1,
        &conf.p1_toml,
        &conf.proof_coc_1,
        &conf.pub_inp_coc_1,
    )
    .context("during generating proof with party 1")?;
    tracing::trace!("Starting co-circom party 2 proof generation ..");
    let rx_2 = bench_co_circom_prover_one_party(
        conf,
        &conf.wtns_shr_2,
        &conf.p2_toml,
        &conf.proof_coc_2,
        &conf.pub_inp_coc_2,
    )
    .context("during generating proof with party 2")?;
    tracing::trace!("Starting co-circom party 3 proof generation ..");
    let rx_3 = bench_co_circom_prover_one_party(
        conf,
        &conf.wtns_shr_3,
        &conf.p3_toml,
        &conf.proof_coc_3,
        &conf.pub_inp_coc_3,
    )
    .context("during generating proof with party 3")?;

    let res_1 = rx_1
        .recv()
        .context("during receiving prover time for party 1")?;
    let res_2 = rx_2
        .recv()
        .context("during receiving prover time for party 2")?;
    let res_3 = rx_3
        .recv()
        .context("during receiving prover time for party 3")?;

    tracing::debug!("Prover time party 1: {:?}", res_1);
    tracing::debug!("Prover time party 2: {:?}", res_2);
    tracing::debug!("Prover time party 3: {:?}", res_3);

    Ok(std::cmp::min(res_1, std::cmp::min(res_2, res_3)))
}

fn bench_co_circom_gen_wtns_one_party(
    conf: &Config,
    inp_shr: &Option<std::path::PathBuf>,
    config_toml: &Path,
    wtns_shr: &Path,
) -> color_eyre::Result<std::sync::mpsc::Receiver<std::time::Duration>> {
    let conf_tmp = conf.clone();
    let inp_shr = inp_shr.clone();
    let config_toml = config_toml.to_owned();
    let wtns_shr = wtns_shr.to_owned();
    let (tx, rx) = channel();
    thread::spawn(move || {
        let conf = conf_tmp;
        let now = Instant::now();
        let out_coc_gen_wtns = Command::new(&conf.co_circom_bin)
            .arg("generate-witness")
            .arg("--input")
            .arg(inp_shr.as_ref().expect("gen witness is true").as_path())
            .arg("--circuit")
            .arg(conf.circom.as_ref().expect("gen witness is true").as_path())
            .arg("--protocol")
            .arg(&conf.protocol)
            .arg("--curve")
            .arg(&conf.curve)
            .arg("--config")
            .arg(config_toml)
            .arg("--out")
            .arg(wtns_shr)
            .args(link_library_to_args(&conf, "--link-library")?)
            .output()
            .context("during executing \"co-circom generate-witness\"")?;
        let res = now.elapsed();
        if !out_coc_gen_wtns.status.success() {
            tracing::error!(
                "Failed to generate shared witness: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_coc_gen_wtns.stdout)?,
                std::str::from_utf8(&out_coc_gen_wtns.stderr)?
            );
            return Err(eyre!("Failed to generate shared witness"));
        }
        tx.send(res).unwrap();
        Ok(())
    });
    Ok(rx)
}

fn bench_co_circom_gen_wtns(conf: &Config) -> color_eyre::Result<Duration> {
    tracing::trace!("Starting co-circom party 1 shared witness generation ..");
    let res_1 = bench_co_circom_gen_wtns_one_party(
        conf,
        &conf.gen_inp_shr_1,
        &conf.p1_toml,
        &conf.wtns_shr_1,
    )
    .context("during generating witness share for party 1")?;
    tracing::trace!("Starting co-circom party 2 shared witness generation ..");
    let res_2 = bench_co_circom_gen_wtns_one_party(
        conf,
        &conf.gen_inp_shr_2,
        &conf.p2_toml,
        &conf.wtns_shr_2,
    )
    .context("during generating witness share for party 2")?;
    tracing::trace!("Starting co-circom party 3 shared witness generation ..");
    let res_3 = bench_co_circom_gen_wtns_one_party(
        conf,
        &conf.gen_inp_shr_3,
        &conf.p3_toml,
        &conf.wtns_shr_3,
    )
    .context("during generating witness share for party 3")?;
    let res_1 = res_1
        .recv()
        .context("during receiving witness generation time for party 1")?;
    let res_2 = res_2
        .recv()
        .context("during receiving witness generation time for party 2")?;
    let res_3 = res_3
        .recv()
        .context("during receiving witness generation time for party 3")?;
    tracing::debug!("Witness generation time party 1: {:?}", res_1);
    tracing::debug!("Witness generation time party 2: {:?}", res_2);
    tracing::debug!("Witness generation time party 3: {:?}", res_3);
    Ok(std::cmp::min(res_1, std::cmp::min(res_2, res_3)))
}

fn link_library_to_args(conf: &Config, flag: &str) -> color_eyre::Result<Vec<String>> {
    let mut result = Vec::new();
    if let Some(link_library) = &conf.link_library {
        for lib in link_library {
            result.push(flag.to_string());
            result.push(lib.clone());
        }
    }
    Ok(result)
}

fn bench_co_circom(conf: &Config) -> color_eyre::Result<BenchResult> {
    create_party_toml_files(conf).context("during creating party toml files")?;
    let mut wtns_gen_time = None;
    if conf.do_gen_witness {
        tracing::trace!("Splitting input into shares using co-circom ..");
        let out_coc_split = Command::new(&conf.co_circom_bin)
            .arg("split-input")
            .arg("--input")
            .arg(conf.input.as_ref().expect("gen witness is true").as_path())
            .arg("--circuit")
            .arg(conf.circom.as_ref().expect("gen witness is true").as_path())
            .arg("--protocol")
            .arg(&conf.protocol)
            .arg("--curve")
            .arg(&conf.curve)
            .arg("--out-dir")
            .arg(".")
            .args(link_library_to_args(conf, "--link-library")?)
            .output()
            .context("during executing \"co-circom split-input\"")?;
        if !out_coc_split.status.success() {
            tracing::error!(
                "Failed to split input into shares: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_coc_split.stdout)?,
                std::str::from_utf8(&out_coc_split.stderr)?
            );
            return Err(eyre!("Failed to split input into shares"));
        }
        tracing::trace!("Generating witness using co-circom ..");
        wtns_gen_time =
            Some(bench_co_circom_gen_wtns(conf).context("during benching co-circom gen-wtns")?);
    } else {
        tracing::trace!("Splitting witness ..");
        let out_co_circom_split_witness = Command::new(&conf.co_circom_bin)
            .arg("split-witness")
            .arg("--witness")
            .arg(
                conf.witness
                    .as_ref()
                    .expect("gen witness is false")
                    .as_path(),
            )
            .arg("--r1cs")
            .arg(conf.r1cs.as_ref().expect("gen witness is false").as_path())
            .arg("--protocol")
            .arg(&conf.protocol)
            .arg("--curve")
            .arg(&conf.curve)
            .arg("--out-dir")
            .arg(
                conf.witness_path
                    .as_ref()
                    .expect("gen witness is false")
                    .as_path(),
            )
            .output()
            .context("during executing \"co-circom split-witness\"")?;
        if !out_co_circom_split_witness.status.success() {
            tracing::error!(
                "Failed to split witness: \nstdout:\n{}\nstderr:\n{}",
                std::str::from_utf8(&out_co_circom_split_witness.stdout)?,
                std::str::from_utf8(&out_co_circom_split_witness.stderr)?
            );
            return Err(eyre!("Failed to split witness"));
        }
    }
    let wtns_gen_time = wtns_gen_time;

    let prover_time = bench_co_circom_prover(conf).context("during benching co-circom prover")?;

    tracing::trace!("Starting co-circom verifier ..");
    let now = Instant::now();
    let out_co_circom_verifier = Command::new(&conf.co_circom_bin)
        .arg("verify")
        .arg(&conf.proof_system)
        .arg("--curve")
        .arg(&conf.curve)
        .arg("--proof")
        .arg(conf.proof_coc_1.as_path())
        .arg("--vk")
        .arg(conf.vkey.as_path())
        .arg("--public-input")
        .arg(conf.pub_inp_coc_1.as_path())
        .output()
        .context("during executing \"co-circom verify\"")?;
    let verifier_time = now.elapsed();
    if !out_co_circom_verifier.status.success() {
        tracing::error!(
            "Failed to verify proof: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_co_circom_verifier.stdout)?,
            std::str::from_utf8(&out_co_circom_verifier.stderr)?
        );
        return Err(eyre!("Failed to verify proof"));
    }

    Ok(BenchResult {
        gen_wtns: wtns_gen_time,
        prove: prover_time,
        verify: verifier_time,
    })
}

fn generate_r1cs_for_zkey_gen(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Generating r1cs ..");
    // to ensure proper naming of the output file, we copy the circom file to a new file with the name of the tmp r1cs file
    std::fs::copy(
        conf.circom.as_ref().expect("gen witness is true"),
        &conf.r1cs_gen,
    )
    .context("during copying circom file to tmp r1cs file")?;
    // circom circuit.circom --r1cs -o path
    let out_circom = Command::new(&conf.circom_bin)
        .arg(conf.r1cs_gen.as_path())
        .arg("--r1cs")
        .arg("-o")
        .arg(conf.r1cs_gen_path.as_path())
        .args(link_library_to_args(conf, "-l")?)
        .output()
        .context("during executing circom")?;
    if !out_circom.status.success() {
        tracing::error!(
            "Failed during executing circom: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_circom.stdout)?,
            std::str::from_utf8(&out_circom.stderr)?
        );
        return Err(eyre!("Failed during executing circom"));
    }
    Ok(())
}

fn generate_zkey(conf: &Config) -> color_eyre::Result<()> {
    if conf.zkey.is_file() && !conf.gen_zkey_force {
        tracing::info!(
            "zkey already exists, skipping generation .. (consider using --gen-zkey-force)"
        );
        return Ok(());
    }
    let now = Instant::now();
    tracing::info!("Generating zkey using power {} ..", conf.pot_power);
    generate_r1cs_for_zkey_gen(conf).context("during generating r1cs")?;
    tracing::trace!("Phase 1: Starting \"snarkjs powersoftau new\" ..");
    // snarkjs powersoftau new bn128 12 pot12_0000.ptau -v
    let out_1 = Command::new(&conf.snarkjs_bin)
        .arg("powersoftau")
        .arg("new")
        .arg("bn128")
        .arg(conf.pot_power.to_string())
        .arg(conf.pot_0000.as_path())
        .arg("-v")
        .output()
        .context("during executing \"snarkjs powersoftau new\"")?;
    if !out_1.status.success() {
        tracing::error!(
            "Failed on \"snarkjs powersoftau new\": \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_1.stdout)?,
            std::str::from_utf8(&out_1.stderr)?
        );
        return Err(eyre!("Failed on \"snarkjs powersoftau new\""));
    }
    tracing::trace!("Phase 1: Starting \"snarkjs powersoftau contribute\" ..");
    // snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="First contribution" -v
    let mut spawn_2 = Command::new(&conf.snarkjs_bin)
        .arg("powersoftau")
        .arg("contribute")
        .arg(conf.pot_0000.as_path())
        .arg(conf.pot_0001.as_path())
        .arg("--name=\"First contribution\"")
        .arg("-v")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context("during executing \"snarkjs powersoftau contribute\"")?;
    if let Some(mut stdin) = spawn_2.stdin.take() {
        stdin
            .write_all(b"nice randomness!\n")
            .context("during writing to stdin")?;
    } else {
        spawn_2.kill().context("during killing process because failed to write to stdin during executing \"snarkjs powersoftau contribute\"")?;
        return Err(eyre!(
            "Failed to write to stdin during executing \"snarkjs powersoftau contribute\""
        ));
    }
    let out_2 = spawn_2
        .wait_with_output()
        .context("during waiting for output of \"snarkjs powersoftau contribute\"")?;
    if !out_2.status.success() {
        tracing::error!(
            "Failed on \"snarkjs powersoftau contribute\": \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_2.stdout)?,
            std::str::from_utf8(&out_2.stderr)?
        );
        return Err(eyre!("Failed on \"snarkjs powersoftau contribute\""));
    }
    // Phase 2
    tracing::trace!("Phase 2: Starting \"snarkjs powersoftau prepare phase2\" ..");
    // snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v
    let out_3 = Command::new(&conf.snarkjs_bin)
        .arg("powersoftau")
        .arg("prepare")
        .arg("phase2")
        .arg(conf.pot_0001.as_path())
        .arg(conf.pot_final.as_path())
        .arg("-v")
        .output()
        .context("during executing \"snarkjs powersoftau prepare phase2\"")?;
    if !out_3.status.success() {
        tracing::error!(
            "Failed on \"snarkjs powersoftau prepare phase2\": \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_3.stdout)?,
            std::str::from_utf8(&out_3.stderr)?
        );
        return Err(eyre!("Failed on \"snarkjs powersoftau prepare phase2\""));
    }
    tracing::trace!("Phase 2: Starting \"snarkjs groth16 setup\" ..");
    // snarkjs groth16 setup multiplier2.r1cs pot12_final.ptau multiplier2_0000.zkey
    let out_4 = Command::new(&conf.snarkjs_bin)
        .arg("groth16")
        .arg("setup")
        .arg(conf.r1cs_gen.as_path())
        .arg(conf.pot_final.as_path())
        .arg(conf.circ_0000.as_path())
        .output()
        .context("during executing \"snarkjs groth16 setup\"")?;
    if !out_4.status.success() {
        tracing::error!(
            "Failed on \"snarkjs groth16 setup\": \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_4.stdout)?,
            std::str::from_utf8(&out_4.stderr)?
        );
        return Err(eyre!("Failed on \"snarkjs groth16 setup\""));
    }
    tracing::trace!("Phase 2: Starting \"snarkjs zkey contribute\" ..");
    // snarkjs zkey contribute multiplier2_0000.zkey multiplier2_0001.zkey --name="1st Contributor Name" -v
    let mut spawn_5 = Command::new(&conf.snarkjs_bin)
        .arg("zkey")
        .arg("contribute")
        .arg(conf.circ_0000.as_path())
        .arg(conf.zkey.as_path())
        .arg("--name=\"1st Contributor Name\"")
        .arg("-v")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context("during executing \"snarkjs zkey contribute\"")?;
    if let Some(mut stdin) = spawn_5.stdin.take() {
        stdin
            .write_all(b"nice other randomness!\n")
            .context("during writing to stdin")?;
    } else {
        spawn_5.kill().context("during killing process because failed to write to stdin during executing \"snarkjs zkey contribute\"")?;
        return Err(eyre!(
            "Failed to write to stdin during executing \"snarkjs zkey contribute\""
        ));
    }
    let out_5 = spawn_5
        .wait_with_output()
        .context("during waiting for output of \"snarkjs zkey contribute\"")?;
    if !out_5.status.success() {
        tracing::error!(
            "Failed on \"snarkjs zkey contribute\": \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_5.stdout)?,
            std::str::from_utf8(&out_5.stderr)?
        );
        return Err(eyre!("Failed on \"snarkjs zkey contribute\""));
    }
    let zkey_time = now.elapsed();
    tracing::info!(".. generating zkey took {:?}", zkey_time);
    Ok(())
}

fn prepare(conf: &Config) -> color_eyre::Result<()> {
    if conf.gen_zkey {
        generate_zkey(conf).context("during generating zkey (consider using --pot-power <NUM> in case snarkjs complains about the ceremony not being large enough)")?;
    }
    tracing::trace!("Exporting verification key ..");
    let out_snarkjs = Command::new("snarkjs")
        .arg("zkey")
        .arg("export")
        .arg("verificationkey")
        .arg(conf.zkey.as_path())
        .arg(conf.vkey.as_path())
        .output()
        .context("during executing \"snarkjs zkey export\"")?;
    if !out_snarkjs.status.success() {
        tracing::error!(
            "Failed to export verification key: \nstdout:\n{}\nstderr:\n{}",
            std::str::from_utf8(&out_snarkjs.stdout)?,
            std::str::from_utf8(&out_snarkjs.stderr)?
        );
        return Err(eyre!("Failed to export verification key"));
    }
    Ok(())
}

fn check_args(conf: &Config) -> color_eyre::Result<()> {
    tracing::trace!("Checking args ..");
    if conf.do_gen_witness {
        check_file_exists(conf.input.as_ref().expect("gen witness is true"))
            .context("checking existence of input file")?;
        check_file_exists(conf.circom.as_ref().expect("gen witness is true"))
            .context("checking existence of circom file")?;
        if !conf
            .circom
            .as_ref()
            .expect("gen witness is true")
            .to_str()
            .unwrap()
            .ends_with(".circom")
        {
            return Err(eyre!("circom file must have .circom extension"));
        }
        if conf
            .circom
            .as_ref()
            .expect("gen witness is true")
            .as_os_str()
            .len()
            < 8
        {
            return Err(eyre!("circom file must have a name before the extension, i.e. it must not be \".circom\""));
        }
        let out_circom_check = Command::new("which")
            .arg(&conf.circom_bin)
            .output()
            .context("during checking existence of circom binary")?;
        if !out_circom_check.status.success() {
            return Err(eyre!("circom executable not found: {}", &conf.circom_bin));
        }
        let out_node_check = Command::new("which")
            .arg(&conf.node_bin)
            .output()
            .context("during checking existence of node binary")?;
        if !out_node_check.status.success() {
            return Err(eyre!("node executable not found: {}", conf.node_bin));
        }
    } else {
        check_file_exists(conf.witness.as_ref().expect("gen witness is true"))
            .context("checking existence of witness file")?;
        check_file_exists(conf.r1cs.as_ref().expect("gen witness is true"))
            .context("checking existence of r1cs file")?;
    }
    if !&conf.gen_zkey {
        check_file_exists(&conf.zkey).context("checking existence of zkey file")?;
    }
    check_dir_exists(&conf.data).context("checking existence of data directory")?;
    check_file_exists(&conf.p1_cert).context("checking existence of party 1 certificate")?;
    check_file_exists(&conf.p2_cert).context("checking existence of party 2 certificate")?;
    check_file_exists(&conf.p3_cert).context("checking existence of party 3 certificate")?;
    check_file_exists(&conf.p1_key).context("checking existence of party 1 key")?;
    check_file_exists(&conf.p2_key).context("checking existence of party 2 key")?;
    check_file_exists(&conf.p3_key).context("checking existence of party 3 key")?;
    let out_co_circom_check = Command::new("which")
        .arg(&conf.co_circom_bin)
        .output()
        .context("during checking existence of co_circom binary")?;
    if !out_co_circom_check.status.success() {
        return Err(eyre!(
            "co-circom executable not found: {}",
            &conf.co_circom_bin
        ));
    }
    let out_snarkjs_check = Command::new("which")
        .arg(&conf.snarkjs_bin)
        .output()
        .context("during checking existence of snarkjs binary")?;
    if !out_snarkjs_check.status.success() {
        return Err(eyre!("snarkjs executable not found: {}", conf.snarkjs_bin));
    }
    Ok(())
}

fn run_with_generating_artifacts(conf: &Config) -> color_eyre::Result<ExitCode> {
    prepare(conf).context("during preparation")?;
    let circom_results = bench_circom_snarkjs(conf).context("during benching circom/snarkjs")?;
    tracing::info!("Results circom: {}", circom_results);
    let co_circom_results = bench_co_circom(conf).context("during benching co_circom")?;
    tracing::info!("Results co-circom: {}", co_circom_results);
    Ok(ExitCode::SUCCESS)
}

macro_rules! rm_file {
    ($path:expr) => {
        if check_file_exists($path).is_ok() {
            std::fs::remove_file($path)
                .context(format!("during removing {} file", stringify!($path)))?;
        }
    };
}

macro_rules! get_gen_wtns_path {
    ($path:expr) => {
        $path.as_ref().expect("gen witness is true").to_owned()
    };
}

fn cleanup(conf: &Config) -> color_eyre::Result<()> {
    if conf.keep_artifacts {
        return Ok(());
    }
    if !conf.keep_pub_inp {
        rm_file!(&conf.pub_inp_sjs);
        rm_file!(&conf.pub_inp_coc_1);
        rm_file!(&conf.pub_inp_coc_2);
        rm_file!(&conf.pub_inp_coc_3);
    }
    if !conf.keep_proof {
        rm_file!(&conf.proof_sjs);
        rm_file!(&conf.proof_coc_1);
        rm_file!(&conf.proof_coc_2);
        rm_file!(&conf.proof_coc_3);
    }
    if !conf.keep_vkey {
        rm_file!(&conf.vkey);
    }
    if !conf.keep_wtns {
        rm_file!(&conf.gen_wtns_file);
        rm_file!(&conf.wtns_shr_1);
        rm_file!(&conf.wtns_shr_2);
        rm_file!(&conf.wtns_shr_3);
    }
    rm_file!(&conf.p1_toml);
    rm_file!(&conf.p2_toml);
    rm_file!(&conf.p3_toml);
    if conf.do_gen_witness {
        let generate_witness_js_folder = get_gen_wtns_path!(conf.generate_witness_js_folder);
        if !conf.keep_inp_shr {
            rm_file!(&get_gen_wtns_path!(conf.gen_inp_shr_1));
            rm_file!(&get_gen_wtns_path!(conf.gen_inp_shr_2));
            rm_file!(&get_gen_wtns_path!(conf.gen_inp_shr_3));
        }
        if check_dir_exists(&generate_witness_js_folder).is_ok() {
            rm_file!(&get_gen_wtns_path!(conf.generate_witness_js));
            rm_file!(&get_gen_wtns_path!(conf.witness_calculator_js));
            rm_file!(&get_gen_wtns_path!(conf.wasm_generated));
            std::fs::remove_dir(&generate_witness_js_folder)
                .context("during removing circom_js directory for the circom witness generation")?;
        }
        rm_file!(&conf.pot_0000);
        rm_file!(&conf.pot_0001);
        rm_file!(&conf.pot_final);
        rm_file!(&conf.circ_0000);
        rm_file!(&conf.r1cs_gen);
    }
    Ok(())
}

fn main() -> color_eyre::Result<ExitCode> {
    install_tracing();
    let args = Cli::parse();
    let conf = Config::from(args);
    check_args(&conf).context("during checking arguments")?;
    let result = run_with_generating_artifacts(&conf);
    cleanup(&conf).context("during cleanup")?;
    result
}
